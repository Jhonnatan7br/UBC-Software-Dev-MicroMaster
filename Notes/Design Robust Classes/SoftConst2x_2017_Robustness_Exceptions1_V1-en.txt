
ELISA BANIASSAD: Earlier we saw that sometimes a program will die
and will give back a strange looking error message
that includes a stack trace.
And we saw that error message is called an exception.
But exceptions are actually not just error messages.
They actually represent a chance to recover the execution of the program
instead of letting it just die.
So let's look in an abstract way at how this exception mechanism basically
works before we look technically at how we code it.
Here is a call stack.
Here we have method main which calls method A, which
calls method B, which calls method C.
And then once method C is over, we return back to B, back to A, back
to main, and then finally the program ends.
And that's what happens when execution proceeds normally.
If something exceptional happens inside of C,
like we index off the end of an array, or we run out of memory,
then what C can do is it can throw something called an exception object.
So what we throw is exception object.
And Java will then pass this exception object back down the call stack.
Now it doesn't do it along the normal return route
because this would have its own return type,
and that's what would get passed back down.
Instead it allows sort of another way of passing this information back
down the call stack.
So it would fall all the way down unless one of the methods along the way
catches it.
So first it would give B the opportunity to catch it,
then it would give A the opportunity to catch it,
and then it would give main the opportunity to catch it.
And if main does not catch it then the program dies.
Now we have a system called the exceptional zoo, which
we will use to explore how we can use exceptions to recover from situations
that would otherwise crash our program.
This project has four classes.
The zoo which is the user interface.
And then it has three classes in the model, the manager, the keeper,
and the animal.
The basic idea here is that we have a zoo, and it has a zoo manager,
and the manager manages the zoo keeper, and the keeper feeds all the animals.
You should take a look through this code yourself.
And then we'll go back to the light board
and take a look at the program structure.
The call stack of the zoo program, when we get to the animal dot eat method,
will look like this.
So we'll have called main, main has called manage, manage has called feed,
feed has called eat.
And if eat does not have any exceptions happen,
or nothing exceptional happens at eat, then eat
will simply return to feed, which will return to manage,
which will return to main, and then the program will end successfully.
This is a very underspecified system.
We're missing a lot of requires, modifies, and effects clauses.
But we do have this one little bit of specification
that says that the eat method requires the animal
to be hungry to run properly.
However, we're calling eat from within feed,
which means that our feed method needs to make sure
that the animal is hungry before calling eat in order to ensure
that it's precondition is met.
This is a perfect situation for using exceptions,
because inside of the feed method we have
this unfortunate internal knowledge about what is
required inside the behavior of animal.
So what we really want is for animal to know about whether it's hungry,
and to be able to return a nope, this didn't work out result. However,
the return value is already taken.
It reflects how many times the animal has eaten.
So we can't actually use the return value as an error result,
and in fact that's often considered pretty bad style because the return
value typically should be substantive value of the method,
and not an incidental error result, especially because we could hand back
errors using the exception mechanism instead.
What we're going to do now is we're going
to put the knowledge about when the animal will eat back inside of animal.
So the keeper just needs to know that it needs to feed,
and the animal will be able to say I did not eat.
This will allow us to take away this requires clause so the keeper no longer
needs to worry about it.
So we're going to add a single exception.
Let's make a package called exceptions.
And all we're going to do is add a new class because exceptions are actually
just Java classes.
So we make a class called not hungry, and right now it's just a class.
To make it an exception, we need to make it extend the exception class in Java.
And now it's an exception.
And actually this is all we need to do to add an exception in our system.
We don't need to put any behavior in here at all.
Exception has a ton of useful behavior that we just inherit.
The name is the only important piece of new information,
because by throwing a certain type of exception
we have already indicated which error we have encountered.
So now we want to go into the model into the animal class
to where we want to throw the exception in the eat method.
We're going to add a condition to set the exception in emotion.
We'll say that if the animal is not hungry, then throw new not hungry.
And this is exactly how exceptions work.
We create this new object that we'll throw down that side path.
And now we can remove the requires clause
because it's no longer required that the animal be hungry.
Immediately, IntelliJ starts complaining.
The reason is that now we have to change the declaration of this method
to reflect that it throws something.
So we have two options.
We can add the exception to the method signature,
or we can surround it with try catch.
Surrounding it with try catch actually makes no sense at this point,
because we're throwing the exception here
because we have encountered something illegal or some exceptional behavior.
And it makes no sense to then catch it and pretend that nothing happened.
No, no, no.
So here what we want to do is add it to the method signature
to indicate that this method is going to throw something back
down the call stack.
Having done that, we've changed the method
signature of eat, which means that anything that calls eat
needs to handle this exception.
It's like we've changed a parameter or a return type.
The caller needs to adjust its call to accommodate that change.
So now the keeper dot feed method is unhappy
because it no longer looks the same.
Now we have the same two options offered to us again.
We can once again surround with try catch, which basically
means this is the method that will deal with the fallout
from that other method.
But in our design we've decided it is above the keeper's paygrade
to deal with the animal not eating.
The keeper is told to feed so the keeper feeds.
So he doesn't want to handle this exception,
he just wants to ignore it and let it fall even further down the call stack.
And that's the second option, add the exception to the method signature
again.
And that means I am ignoring this exception.
If it comes back to me, I am just passing it further along.
But a very, very cool thing has happened here,
and that is that the keeper no longer needs to worry about
whether the animal is hungry or not.
It's just stopped caring.
It's not the greatest trait in an employee,
but basically because we've removed this requires clause,
the keeper can do his job oblivious to the risk of the animal
not being hungry, and therefore not eating.
Now we can remove all of this conditional behavior around animal dot
eat because it no longer needs to check this.
The keeper can just feed the animal, and if something exceptional happens
then the exception will be thrown further.
But the fact that this exception is being thrown down the call stack
by the keeper has now made the manager's manage method unhappy, so same thing
again.
Now the keeper's feed method is potentially
going to throw back an exception, and so manage has these same two choices,
deal with it or pass it on.
And in this case we can catch it.
And the manager can do something to recover the operations of the zoo.
So we want to surround with try catch in this case.
And that fills in a line of code that prints
the stack trace, which is always handy if you want to know what happened.
But in this case, we want to additionally print out
a message that just said feed less often.
Let's visually go over what we did there.
Inside of eat, we declared that we would be throwing the exception.
So this arrow is going to represent throwing an exception.
We did the same thing inside of feed.
So rather than catching that exception inside of feed,
we just kept throwing it on.
However inside of manage we caught the exception.
So when eat threw the exception, it came out through this pathway,
killed the rest of the method, continued falling through,
killed the rest of this method, killed this return-path,
but then got caught in manage, which allowed the rest of the manage method
to execute and the rest of the main method to execute.
Let's go into the animal and set its hunger to false,
because that means that the animal is going to throw this exception.
So let's go back into zoo and run our code.
And what we get instead is that the zoo is open for business,
the manager is managing the keeper, the keeper is feeding the animals,
and then the exception must have been thrown.
So we can see the manager catching it and yelling feed less often,
and then the not hungry exception being thrown.
And we can watch all of this happen by placing a breakpoint in the eat method.
So we can step to where the exception is thrown, and if we step over again
we've zoomed all the way back to the manage method.
We've skipped the rest of the animals eat method, the rest of the keeper's
feed method, and we've gone directly out to where the exception was caught,
which is in manager dot manage.
So we catch the exception, print the stack trace, and then we print it out,
feed less often, and we're done.