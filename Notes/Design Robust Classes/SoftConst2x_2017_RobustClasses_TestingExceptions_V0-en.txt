
ELISA BANIASSAD: When testing exceptions,
we're actually looking for the exception to be thrown.
So we're going to be trying to catch the correct exception
in the correct situation.
So we want to look at all the inputs to our method
and then figure out what the exceptions should be that we're expecting.
The only normal execution scenario of this method
is that the animal is hungry and is not allergic.
In that case, we want to make sure that no exceptions are thrown
and that eat is incremented.
If the animal is not hungry and not allergic,
then the not hungry exception will be thrown.
So we want to look for the didn't eat exception.

If the animal is hungry but is also allergic,
then an exception will be thrown from this case, in which case
we should expect to see the is allergic exception or the allergy exception.

If the animal is not hungry and is allergic--
this is the worst case scenario--
just this exception will be thrown, because once this exception is
thrown nothing else actually happens.
So here we would just be expecting to see the didn't eat exception.

First we need to enhance the testability of our class
by creating a new constructor that sets the state of the animal.
We could also have done this with a pair of setters
if that seemed like a better choice.
So let's write test for the first couple of these scenarios
that we discussed and you can do the others for yourself.
So first let's make a test Package and inside it we'll
make a new Java class called Animal Test.
And we'll create a new test called eat is hungry
not allergic, which is the scenario we'll be testing.
So we'll include JUnit5 in our classpath and actually in JUnit4 there's
a different way to test exceptions.
But since that's not included in JUnit5, I'm
just going to do the simple version of testing for exceptions generally.
There is a more sophisticated way to test exceptions included in JUnit5,
but since it's so much more sophisticated
we'll just stick with the simple but totally functional version.
So let's write down what we're expecting.
We expect eatenTimes to be one and no exceptions to be thrown.
So let's set up a new animal.
The animal in each of our tests will likely be different,
so I'm not going to worry about making a setup method right now.
We're going to say that is hungry is true and is allergic is false
and end eatenTimes, which is our own local variable, is zero.
Now we're going to try and call our method of interest.
We'll say eatenTimes equals animal.eat.
So we're invoking the behavior we want to test.
So we'll let IntelliJ help us by creating a catch block.
And now here's the interesting thing, if we actually catch the exception then
our test should fail.
We're expecting to catch no exceptions, so we
can say fail and put in a printout for ourselves
in the catch clause for both of the exceptions, which is great.
Our test will fail if either of the exceptions are thrown.
But we also want to make sure that eatenTimes is incremented.
So we'll say assertTrue eatenTimes equals equals 1.
So now if we run this test it should pass, and look at that it does.
Now let's make a second test for a situation
where we're trying to get an exception.
So we'll call it eat not hungry not allergic.
So we'll make a note about what we're expecting, a not hungry exception
to be thrown and for eatenTimes to remain zero.
So we'll copy in these two lines to edit from
and this time we want hungry to be false and allergic to be false.
And we'll set up or try catch block the same way as the test above.
And the allergy exception should still make the test fail,
but this time the not hungry exception will do absolutely nothing because we
are expecting to catch this exception.
If we catch this exception, execution will
keep flowing over into a assertTrue eatenTimes equals equals 0.
Now let's run this one and see what happens.
Oh, and it passes.
As I've said before, it's a really good idea to try and break your code
and make sure that some test fails in response to the broken code.
So let's do that.
We haven't finished writing tests for all the circumstances,
so some of our mutations might not cause tests to fail.
But we know that we should at least see the not hungry exception come through.
So, if we comment that throwing of the exception out
we should see our second test fail.
So let's run all of our tests again.
And indeed this test fails, which is perfect.
That means that our test is catching that line of code.
Great.
And now let's undo that.
So now what you want to do is go in and write tests for the rest of the grid.