
REID HOLMES: The simplest form of static analysis tool is,
of course, just a compiler.
So here, if we go and try to compile our code, tsc testlevels,
we'll see that this returns an error, TS1005, saying a comma is expected.
And if we go into the code, we can see that indeed, there's
a comma missing here.
And there was an annotation, although this annotation within the ID
comes from the compiler itself.
And if we fix it and go back to the code and compile it, it's going to be fine.
But the compiler can also tell about other errors.
So if we, for instance, put the string 15 here instead of the number 15,
and we go back and compile this code here, the compiler will complain
and say this is a violation of the spec.
The property height cannot be a string.
It has to be a number.
And this static analysis helps us to understand that.
So we can go back and change this to a number, recompile,
and everything will be fine.
So this really is a static analysis.
It's ingesting our source code and it's giving us a series of errors.
Now, one downside of compilers is they don't really
give us any semantic warnings, since they're just
validating the syntax of our code.
And this is where linters come in.
Linters are a class of tools that try to give us
semantic warnings that can help us avoid common mistakes within our systems.
They do this by applying a variety of heuristics
that can identify the kinds of problems that could be problematic in the future
Linters often also check the code to ensure
that it adheres to a team's code style guide,
for instance, by checking the indentation and how braces are used.
This keeps the code looking consistent, making it easier for all team
members to sit down and work on the code without working out the developer's
personal style who wrote that code.
Linting tools all publish the heuristics they use to validate the code.
And if we go to the TSLint heuristics here,
we can see that they're extremely comprehensive.
It's important to realize that these aren't all explicit errors.
They're just warnings.
So some development teams might choose to use different sets of warnings
than other development teams.
And that will really vary domain to domain
based on your project-specific needs.
Let's look at some concrete examples and really dive
into the code to look at what lint can tell us.
The first warning we see here is that the getVelocity method is
unused by anywhere within the system.
And while this code looks reasonable, there's really no need for us
to keep it around and evolve it over time.
This is just technical debt that has no value at all,
so really, we should remove this.
And this is the kind of thing that lint can show us.
Another example is within the collides method.
And here, we can see that several of these var declarations
have been given the same warning.
What this warning really says is that by using the var keyword,
we hoist this variable up to the scope of the entire method,
rather than just within this block.
If instead we used let, it would be restricted to within this block alone.
Let's take a look at a concrete example.
So here we have O-B-J, obj.
And we can go and reference obj up here.
We can even set its value.
We'll set it to null.
And this won't be a problem.
And it looks like it should be a problem.
We're obviously setting it to null before it's been declared.
But because it gets hoisted up to the level of the whole method,
this code actually works out.
But now if we change it to let, we can see
that there is an error, because obj isn't visible
if we've declared the value of the variable with a let.
And this is why a let construct is always better than a var construct.
So we can do this in these for loops.
And the problem will be fixed as well.
Of course, we can go one step further.
We can also just set obj to be const.
This just means that the variable won't be overwritten again anywhere
else within this method, which might be really beneficial if that's
your intent.
Linters can also detect really simple problems, like within the bullet class.
So here we can see that the lint warning is that the file should
end with a new line.
And when we add that, we actually get another warning
that this semicolon is unnecessary.
So we can remove that as well.
So lint warnings do not necessarily need to be overly detrimental.
They can also catch simple problems.
Another example of this is within the Mario setCoins method.
And if we go here, we can see that at this call
to addLife is actually missing a semicolon.
Again, it's not needed, but it would be consistent with the rest of our system
by having it.
So we should just add it so all of our code looks the same.
Now let's go back to the grow method within Mario.
And here, we've actually introduced a synthetic error,
and you can see what it is.
In the if statement, we want to check if this.state is a SizeState.small.
But instead, we've gone and made an assignment here.
So the linter actually caught this.
It's definitely a bug.
So we can go and change this from equals to equals equals.
And now, we're going to check equality.
And interestingly, the linter shows us we have a problem here too,
and says we should be using triple equals instead of double equals.
So we'll add the extra equal sign, and now everything works perfectly.
And this is totally the kind of bug you could see yourself
introducing if you're just in a rush.
And it would be a huge pain to debug, because you'd never
hit the else clause here.
It would always be true, and that would be extremely frustrating to debug.