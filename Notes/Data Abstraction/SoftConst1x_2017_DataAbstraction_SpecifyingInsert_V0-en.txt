
ELISA BANIASSAD: OK, so we have decided that our integer set
data abstraction has an insert method.
So now we're going to specify that method.
Finally, now that we know how to write specifications.
But first, we write the signature of the method--
just like you've done in previous courses.
First you write the signature, and then you write the specification.
So I've already written out the signature for this method.
So let's just go through it quickly, and then we'll all be on the same page.
So of course, it's a public method, because we want other classes
to be able to call it from the outside.
Second, it's a void return type, which means that the method is just
going to run and then complete its work and not return anything explicitly
back.
Next, of course, is the name-- insert.
And then the parameter list.
The parameter type is important.
It's an integer that we're passing in.
The name isn't as important.
It's just an arbitrarily chosen name, but it's always
good to pick something meaningful.
So we have public void insert integer--
that's our whole signature.
And then, just because it feels weird to have a signature sitting there
without the body of a method, we just put a little fake placeholder body here
to hold down the body of the method block.
All right, so now let's remember all of the parts of our specification,
and let's write those up first.
And then we can fill them in as we think about it.
So first, of course, is the requires clause.

So what are the preconditions that the method needs in order to run properly?
Then there is the modifies clause.

Does this method change anything about this data abstraction, or other data
abstractions?
And finally, there is the effects clause.

What does the method actually do?
OK, so now let's consider each of these questions in turn.
OK, so the first thing that we are going to consider is the requires clause.
So what does this method require in order to run properly?
It takes one parameter-- the integer--
and there are no real requirements on that parameter.
It can be anything, as long as it's an integer.
And if it's not an integer, then the compiler will complain
and we won't be able to run anything anyway.
So that's good.
Everything is checked in that sense.
And there's nothing else that we need to worry about for this parameter.
And there are no other real setup things that we need to run this insert method.
So actually, this method doesn't require anything.
You can run this method any time.
So in that case, what we could do is write requires nothing.
But actually, what we do if we would be writing requires nothing,
is we simply don't write a requires clause at all.
We'll just erase this whole thing out, because we actually
only use the parts of the specification that we need.
So this requires clause wouldn't even fit, or wouldn't even
appear in our final specification for this method.
OK, so now we are ready to think about the modifies clause for our method.
And just to remind you, the modifies clause
indicates that this method mutates something,
either in this data abstraction or in another data abstraction.
Now, an integer is a data abstraction.
And so we could think, is this method modifying this integer?
And it is not.
It doesn't modify this integer at all.
It just puts it into the data abstraction for integer set.
But in doing that, it does change the integer set,
because now it has another integer in it.
This is different from the DSL world, because in DSL,
what you would do is you would make a brand new integer
set that had the new element in it.
But here, we're actually modifying the data abstraction right in place.
So as we did before, to capture that, we just write modifies this.
To capture the fact that it is this data abstraction-- this integer set--
that is mutated by this method.
OK, so now we're ready to think about what this method actually does.
So we know that the basic behavior of this method
is that it will insert a number into the integer set,
as long as the number is not already there.
And if it is already there, then it doesn't do anything.
So we can just write that down in the effects clause.
Remember that in the effects clause, we don't want to write down
the implementation details.
We don't want to write down how we're doing this insertion, how quickly it
runs, anything like that.
We don't want any internal details.
We just want how the effects of this method
will be viewed from the outside world.
So we just write down something like inserts num if not already there.
If there-- if num is there--
do nothing, or does nothing, actually-- does nothing.
So now this tells us what the method does from the perspective
of the outside world.
It inserts the number if it's not already there.
And if the num is there, the method does nothing at all.
So now we have a really well-written entire specification for our method.
We know that it requires nothing, so we actually erase that line entirely.
And we know that it modifies this data abstraction.
It modifies this integer set.
And we know that the effects of this method
are that if you give it a number that's not already in the integer set,
it will insert it.
But if it is already in the integer set, it will do nothing at all.
So that's the entire specification.