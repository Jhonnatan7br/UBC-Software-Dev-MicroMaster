
ELISA BANIASSAD: OK, so now let's think about the effects clause
so that we can figure out how to encode it as a series of test cases.
So let's think conceptually about how the method operates
from the perspective of the outside world.
So when we call the method, the method decides--
is the number that we have passed into the method in the integer set already,
or is it not?
So goes through a decision.
Is num in set?
And that's written right in the effects clause, because remember,
the effects clause has these two cases.
So if the number is in the set, then--

or if the number is not in a set, false.
Then we insert the number into the set, and then the method ends.
That's all it does.
Of course, the other scenario is that the number is actually in the set.
That there's a true branch here.
And in the case that it's in the set actually, we do nothing.
That's what the effects cause does.
So we come right down here to the end of the method.
So this is the basic flow of the method.
We want-- when testing our method-- to make sure
that we test both pathways through the method,
that way we know that we've got all of the scenarios that the method provides.
All right, so we can see that our method follows two paths.
Either the number is not in the set, or it is in the set.
And so what we want to do is we want to write test cases that
exercise both of these pathways.
So let's do the first one first.
That's this pathway.
So to write this test case, obviously we would
need to insert a number into the set that is not already in the set.
So we just write this really straightforwardly.
We, first of all, give the test a name, something like test not already there.
And we would actually probably write test insert not already there,
just because it's always good to have the name of the method right
in the name of the test.
So test insert, not already there.
And what that test will do is it will insert a number that is not already
in the set.

And then we have to decide what the outcome of this test is going to be.
So we know what we're going to run.
We know the test case that we're running.
But we want to know how we'll know if that test is successful, how we'll know
if the method actually ran correctly.
So we encode an outcome.
We say that the outcome should be that the number appears in the set.
So now we know both what we're doing to test the method,
and also how we're checking whether it has behaved correctly.
Now we want to do the other pathway.
So now we want to say that it was already in the set.
So we write a second test case.
So this was one--
this will become one method.
Next we'll look at how this will end up looking when we actually
write the test cases.
But this is basically one test case.
And now we're going to write a second entire test
case that will test this other pathway.
So we'll call this one test insert, because remember,
we want the name of our method in there--
test insert, already there.

And this will insert a number that is already in set.

And again, we want to figure out what the outcome would be.
And the hoped-for outcome in this case is a little bit different, actually,
from this one.
The hoped-for outcome in this case is that the number appears in the set,
but that it only appears once.
So now we need a notion of checking that a number only appears
one time, because remember the specification for integer set
is that every number can only appear once in the set.
So these are our two test cases for our insert method in our integer set.
OK, so the effects clause for our insert method
is actually really, really simple.
It only has these two branches.
One where the number is not already in the set,
and then the other where the number is in the set.
So just to give you more of a feeling of what
you might do if there was a more complicated scenario for inputs,
I've hypothetically augmented this insert method,
and I've changed its signature as well.
And so the signature now returns a string
so that we can test what the output is of our method.
It's not just printing it to screen, but it's actually returning the string.
And it returns different strings depending on the value of the input.
So if it is a negative number--
if it's below negative 1, or negative 1 or below--
it returns that's negative.
If it's 0, it returns that's nothing.
And if it's positive--
if it's 1 or above-- then it returns that's positive.
So you can see, if we drew the branches out,
that there would be one branch for each of those scenarios.
And then, of course, there would be the additional branches
for testing whether it's inside the set already or not.
So you would need one test to test each of those branch scenarios.
But, in fact, testing one of each of the scenarios--
testing one input for each of the scenarios-- it doesn't quite do it,
because--
well, let's just think about what we would do.
We would have negative infinity all the way over to negative 1.
And then you have 0.
And then you have 1.
And then we go all the way over to infinity.
So if we were just testing the branches, we
would probably do a little test here-- at something like negative 5.
And then we would do another little test here, at 0.
And then we would write another little test here, at positive 5.
And then, of course, we would have to do the test already
in and the test not already in.
Those are in addition.
This would get all of the scenarios.
However, writing less than is very, very close to writing less than or equal to.
This is a typo that happens a lot.
And that means that right at this boundary,
you might have a little bug that is sneakily living there.
And so to really rigorously test a method with ranges like this,
you want to add additional test cases that are right at the boundaries.
So you would also want to have a test case that's sat right at negative 1,
and another test that's sat right at this boundary-- right at 1.
And you would leave these middle-of-the-range tests as well.
So in that case, you'd actually have five tests
to thoroughly test all of these branches.
And then, of course, the additional tests
to test if the number's already in the set, or if it's not already in the set.
Now that we know that these are all of the test cases
that we would like to see, let's see how these boundary tests actually
turn into test cases.
So let's just write a couple of them out.
Let's just write out the negative 5 and the negative 1 case.
So first of all, again, we give our test case a name.
So we would say something like test, insert, middle of negative range.

And these names can get quite long.
They should be pretty descriptive, so that you can read the name of the test
and know what it is that you're testing.
So this is the name of our test-- test insert middle of negative range.
And then, how do we actually-- what work would that test do?
It just insert some number between negative infinity and negative 1.
So something anywhere in here.
It doesn't need to be negative 5.
It can be whatever we want.
Now we have to think what the outcome of this test should be.
So the outcome of the test is what we are
expecting to see returned when we pass in something like negative 5.
And as we know from the effects clause, we
are expecting to see that negative come back.
So we want to see returns that's negative.

So similarly, we can write a test case for negative 1.
So we can say test, insert--
again, we write the name of our method--

upper negative boundary.

So this tells us that we're testing right at the boundary
and this is somewhere in the negative range,
so that's nice that we have these really descriptive names.
So test and insert at the upper negative boundary.
And the work that test will do is it will insert negative 1.
And this has to be really specific, because that is
a named boundary in the effects clause.
So we want to be really, really specific about this boundary test
that we're doing.
And the outcome of this one is the same as the other one,
because we want everything in this range to return that's negative.
So the outcome is just, once again, going to be returns that's negative.
So if we were to keep going with this, we would write the same type of thing
for the 0 case.
We would name it something like test insert 0,
and then test insert lower positive boundary,
and then test insert middle of positive range.
And so we would write all of those tests in exactly the same format,
making sure that we tie them to the correct outcomes as described
in the effects clause.