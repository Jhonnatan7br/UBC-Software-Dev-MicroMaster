
ELISA BANIASSAD: OK.
So now we're going to talk about a really important word
when we're talking about abstractions, and that is visibility.
So when we look at an abstraction, we're sort of
seeing it as kind of a donut right now.
We've got kind of this outer portion and this inner portion.
And these actually have names.
One of them, the outer portion, is the visible interface.

This is the way that we hide all of the stuff that's inside
from the outside world, so that when you're
looking at something, at an abstraction from the outside, all you see
is this visible interface.
You can imagine it's kind of like an iceberg.
And the iceberg is floating under the water.
These are terrible waves.
And what you're seeing above the water is the visible interface.
So this is the iceberg view of abstraction.
And underneath the water, or inside of the abstraction,
is what's called the invisible implementation.

And that is what lives inside of here, or is
below the water in the case of the iceberg.
And there are keywords that we use when we're
talking about the visible interface versus the invisible implementation.
And for visible, we say public.
And for the invisible stuff, the stuff that's
living only inside of the abstraction that is not visible from the outside,
we call private.

Now there are actually three kinds of visibility in Java,
but we're going to concentrate on these two for now.
And so the stuff that's private is the stuff
that would be floating underneath the water in the iceberg.
And of course we're not going to get into what
happens if you have scuba gear.
And I just want to point out one very specific thing.
And that is that right now I'm using interface with a small I.
And that's because I'm referring to this concept of a public interface
of a single abstraction.
There's also big I interface, which is a keyword in Java,
and we'll get to that later.
So you can probably imagine lots of things in life
actually working kind of like this iceberg or like this abstraction.
So for instance, imagine if you're ordering pizza from a pizza place.
So let's design this as an abstraction.
Let's say we have a pizza place abstraction.

And our pizza place abstraction will have within it a functional abstraction
called order.
And so what would happen there is you would make a call to order, passing
in the thing that you're ordering.
And then order would use its private implementation
to actually make the pizza.
So you have no idea what's going on in here.
The phone person takes the order and then gives the order to the kitchen.
And the kitchen does all of the things that it takes to make a pizza.
It rolls the dough.
It does all these things, lots and lots of behavior down in here.
Remember this is kind of usually a lot larger than this.
And then the pizza is going to be returned back to you.
And so you just have to hope that this is kind of an OK implementation.
But on some level, you don't care, because if the pizza tastes good,
then you'll order it again.
We can work out the Shape's public interface
by looking at the public keyword in the list of methods.
Unlocked indicates public, whereas locked indicates private.
Notice that all the fields are private and a few of the methods are private.
And then we have this whole load of public methods.
So as we've seen before, Shape has these two public constructors.
Constructors are almost always public because usually
what's happening with an object is that you're using
the constructor from outside the class.
You're making the object from somewhere else.
And then we see that the Shape tool has some getters all collected
together and one setter.
And we're going to go into more detail about that in a sec.
So after the getters and setters, Shape has some other publicly available
behavior.
And this is all part of the publicly visible interface of this class.
And then it has some private stuff, which is
all part of the private implementation.
Any time you see that dot notation, you know
that one class is using the visible interface of another class.
For instance, here in the play method, we see midiSynth.play.
So we're using this public method from midiSynth's publicly visible interface
to invoke the behavior that lives in the midiSynth class.
So we've seen why classes have these public methods,
but they also often use their own private methods
to do their own private implementations.
So for instance, we see this public method selectAndPlay.
It is public, which means the outside world can call it.
But then it has this internal method, play,
that it uses to actually do the work.
And we can jump down and see that play has a bunch of things inside.
Could we have put all the lines of code inside of play
out here in selectAndPlay?
Yeah, maybe we could have.
But it's actually possible that this play behavior
is something that we need to reuse, and so it
might be also called from elsewhere.
Also, we wanted to collapse this behavior
into its little own private helper method to isolate it.
So when we're trying to understand a class,
we first look for its publicly visible interface.
This tells us how this abstraction is used and seen by the outside world.
But if we want to find out how the abstraction works under the hood,
we look for the stuff the public methods use.
And oftentimes, those are internal, private methods.
So now let's talk about getters and setters more directly for a second.
I mentioned them briefly, but now let's take a deeper look.
Getters and setters are public methods that give access to private data.
We want to hide these types of private data
because they're really open to change.
They often change a lot as we make implementation decisions.
So we hide them beneath this public interface that doesn't change a lot
and that other classes can rely on.
That way, it doesn't really matter from the outside
how we implement what's going on within the class.
Here we have all these getters that give access to this private stuff.
For instance, here's the getWidth method.
And that's just going to return width.
Getters and setters are so common and so incredibly standard
that you actually can generate them from within IntelliJ.
They usually just start with the word get and then the name of the variable.
So these two, getXCoord and getYCoord, are a little different.
They could just be getX and getY, but it's the same idea.
And if the variable is a Boolean, we change the name slightly like this.
So we have isSelected instead of getSelected.
So now we know that we use getters to get public access to private data
so we can see their values.
But if we want to change the value of private data from the outside,
we use setters.
So let's take a peek in here.
We can see the setPlayLineCoord method, which
allows us to change the value of this private field.
And again, it protects the caller from any underlying changes
to the implementation of that field.
So why is it that we need this iceberg kind of arrangement?
Why is it that we need a public interface that's
visible from the outside and a private implementation that
is hidden from view?
Well, a lot of it has to do with the propagation of changes.
So typically over the life of a data abstraction,
you're going to have lots and lots and lots of changes in here.
You're going to have debugging.
You're going to have changes in decisions about the way
that you store information, et cetera.
And any time one class uses another class,
or one method calls another method, if this method changes,
then you're going to have to change the caller as well.
So you want to kind of limit the points at which other kind of clients
are reliant on this data abstraction.
So by having this arrangement, you force everybody
to relate only to what is floating above the surface.
And what's floating up here should change very, very little.
Typically what you do is you design your data abstraction,
such that it remains fairly stable.
Under here can change a lot.
But up here remains steady so that the callers can rely on it
and so that they don't have to change in response to changes
that are happening down here.