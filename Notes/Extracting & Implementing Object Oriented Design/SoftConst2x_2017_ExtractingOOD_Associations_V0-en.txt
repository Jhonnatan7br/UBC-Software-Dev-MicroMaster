ELISA BANIASSAD: Now we're going to look at including associations
in our class diagram.
We're not going to have absolutely every type of association
that you could have in a diagram, but we're
going to have a nice subset that lets us communicate our design ideas.
So here we have all of the declarations from Drawing Editor.
Using the fields from Drawing Editor, let's look at all of its associations.
So first, we can see that Drawing Editor extends
JFrame, which is part of the class hierarchy diagram that we had before.
But also, often these diagrams are kind of merged,
so let's just draw that relationship in.
Now let's go through each of the fields, storing the association arrows,
depicting them individually.
So what we're looking at here are just the type declarations.
We don't care at all about the names of these fields.
They're not interesting.
We just look at the declarations of the types,
and then we use those to decide where our arrows are pointing.
So here we have a field that's of type MidiSynth,
so we know we're going to have an arrow that
goes from Drawing Editor to MidiSynth.
Then we look at how many MidiSynths the drawing editor actually has.
So it only has one MidiSynth.
It's not a list of MidiSynths, just one.
So we could put a number 1 here at the arrow head,
or we could leave the number 2 off, because 1 is actually
the default for the association.
Next, we see that Drawing Editor has a list of tools.
So we draw our association in, and then we
have to determine whether it's an arbitrarily-sized list, in which case
we would put a star, or a fixed-sized list, in which case we put the number.
In this case, we're adding the tools individually.
We know exactly how many there are.
So we would put that number right by the arrow head indicating
the area of the relationship.
Next, we see another field, also of type tool.
Now, it already has six tools, so we don't actually
need to add another tool field.
We're not trying to generate code from this diagram,
so we don't need a second arrow to get that second line of declaration.
Instead, we leave it like this, and that gives us
enough information about the relationship
between Drawing Editor and tool.
And finally, we see our drawing field, so we
draw a line from Drawing Editor pointing to drawing.
And again, we could optionally put the 1 there
to indicate that there's only one drawing that
lives inside of Drawing Editor.
Next, we want to think about the strength of the relationships
that we've just depicted.
Are they simply knows about relationships?
Does the drawing editor just know about the MidiSynth?
Or is the MidiSynth really a part of the Drawing Editor?
We call the special relationship an aggregation.
Now we go through and decide whether each of these
is an aggregation relationship.
An aggregation relationship is depicted with a diamond
at the base of the arrow, at the source of the arrow.
So if MidiSynth is really part of the Drawing Editor-- which it kind of is,
because the Drawing Editor is a drawing editor.
Inside of that lives the MidiSynth.
Similarly, a drawing is really inside owned by the Drawing Editor,
and as are all the tools.
So really, each of these could be considered an aggregation relationship.
So to depict that, we put these little diamonds
at the source of each of these arrows.
Now, you need to know that this diamond is not the same as this diamond.
People often associate these diamonds with lists.
But in this case, you can see very clearly
that there is only one mini synth here, but it is still
a contained part of the drawing editor.
So when do we have relationships that are not whole part relationships?
All of these were whole part relationships.
Well, you can imagine that a course has students and an instructor,
but you would be hard pressed to describe yourself as a student
as really being owned by the course, or being part of the course.
Similarly, I don't think I'm really owned by this course.
I do have a life outside.
So we would not put the diamond at the base of these arrows.
Instead, the course knows about a student and knows about an instructor,
but neither of these live right inside of here.
Now, interestingly, this is just a design constraint.
These delineations of aggregation versus regular fields
just exist at the design level.
There is no discernible difference when you
look inside the code about how this relationship is implemented
versus how this relationship is implemented.
It's just so that you can think about the topology of your code
and the relationships between the classes.
So now let's imagine that we've gone into the tool class
to look at its fields, and it has a range of fields,
and we will have depicted the associations to those classes.
However, it also has a field of type Drawing Editor.
Now, we already would have, in our diagram, this relationship,
but it's pointed towards tool.
Now we want to point the arrow back at Drawing Editor.
OK, great.
But there isn't a really nice way to draw an arrow on top of a diamond.
And for that reason, if there's a bi-directional arrow in one
of these diagrams, the arrowhead just totally goes away.
So instead of having two arrows, instead, you
would just have no arrowheads at all.
So remember from our architectural diagram the Drawing
Player imports the Drawing Editor.
So why isn't that relationship showing up
in the associations shown in our class diagram?
The reason is that Drawing Player has no actual Drawing Editor field.
So why does it need to import it at all if it has no formal association to it?
Well, in fact, it has a weaker kind of association.
And that depends upon association.
Because if you look all the way down at the bottom and stop playing when done,
you can see that we use the drawingeditor.width constant.
And that means that we do need the Drawing Editor class.
So to show when we use constants or a local variable of a certain type,
we use this other kind of arrow, this simple dashed arrow,
to show that Drawing Player, in some non-field way,
depends upon the Drawing Editor.