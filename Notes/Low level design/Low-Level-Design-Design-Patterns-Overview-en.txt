
REID HOLMES: Christopher Alexander is a famous architect
of actual physical buildings who spent his career coming up
with patterns that captured how the buildings were designed, built,
and how they evolved over time.
One of the most interesting things about his work
isn't the patterns that he found, but the problems that these patterns were
trying to address.
So as a software engineer, we want to do something similar.
We want to learn from design patterns to see what kinds of problems people
have encountered in building software systems in the past
and figure out how we can design our systems better to avoid encountering
these kinds of problems in the future.
Design patterns provide us a set of guidelines
to structure our systems to avoid future evolutionary problems.
At their core, all design patterns are trying to leverage the previous design
knowledge that other developers have collected
through their own experiences.
Design patterns also give us a way of really building flexibility
into our systems in a variety of different ways,
depending on the situation that we're trying to address.
Now, one great thing about design patterns
is they introduce a shared and common vocabulary between developers.
So if I say observer, everybody who's a developer,
every industrial engineer is going to know what the observer pattern means
and what the implications of that are.
And, luckily, you've covered this in a previous course as well.
Design patterns also put a heavy emphasis
on structuring our systems in such a way that makes them more reusable,
which is the kind of property that's often missed when we
try to build our systems in practice.
Before we dig into design patterns, I think
it's really important to step back and really acknowledge
that there are many situations in practice
where design patterns just don't make sense.
Every time we go to add a design pattern to our system, what we're really
going to be doing is we're going to be adding a new abstraction.
And those abstractions make it harder for future developers to understand.
Now, if those abstractions are going to be
used to enable some kind of future extensibility, then, by all means,
go ahead and follow that path.
But if those abstractions never end up being used,
they just make it harder for all future developers
when they're trying to understand and debug your systems.
All design patterns have three main parts.
They have a name.
They have a problem that they're trying to solve--
that is, a specific evolutionary issue that they're trying to improve upon.
And they have a solution.
And this is a succinct and well-understood structural solution
that can be used to improve your system.
Now, because all design patterns are based
on past experiences of other developers, each of these patterns
also has a set of pros and cons associated with them.
So when you're thinking about your design, what you're really going to do
is you're going to reason about the pros and see if they provide benefits
that you care about.
And you're going to make sure that you can afford the cons,
because there are downsides to every pattern.
As we mentioned earlier, one of the benefits of design patterns
is it really does give developers a shared vocabulary.
And the nice thing about having a shared vocabulary
is it means that the developers, when they're talking about their designs,
they can really focus on the design themselves.
Because they can defer details about what specific classes, what roles
a class might play off to the pattern itself.
For instance, in an observer pattern, you know what the observer does.
So you just say, hey that's the observer.
And everyone has a shared understanding of what that means.
This also lets design discussions be a little bit less verbose.
So, again, developers can spend their time
focusing on more key high-level design decisions.
Finally, one thing to keep in mind about patterns
is they can't be mechanically applied.
So if you want to go and add a design pattern to your system,
you're really going to need to go and either design it in upfront
or carefully refactor it into an existing system.
So there's quite a bit of work involved.
So before you embark on this process, it's
important that you take a little bit of time
and really understand what you're trying to do.
One final note about design patterns is, they really are language independent.
So this means that the patterns that we're going to talk about here
should apply for any object-oriented language.
Design patterns really break down into three high-level categories.

The first of these are creational design patterns.
These patterns help us to build objects in an extensible way.

The next are structural patterns, and these
help us to structure our systems in ways that help us
to avoid future evolutionary problems.

The last category of design pattern are behavioral patterns,
and these make it so we can more easily add new behaviors to our systems
at runtime.

So over the next couple of videos, what we're going to do
is look at specific examples of each of these different kinds of patterns.