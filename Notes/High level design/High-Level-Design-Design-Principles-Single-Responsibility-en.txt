
REID HOLMES: There are many catalogs of design principles.
The solid principles provide five high-level guidelines
that are useful for reasoning about object-oriented designs.
Now, it's important to keep in mind that these are just guidelines.
They're not rules.
Sometimes you will end up violating them,
but, usually, they give us a useful lens for reasoning about our designs.
It is also important to remember that these are not comprehensive.
For different systems and different domains,
there will be other principles that are important for those systems.
So just keep that in mind.
Now, we have we seen some of the solid principles before,
but let's take a deeper look at them now.
Software gets harder to understand due to bloat more than any other reason.
What the single responsibility principle says
is that a software module should do one thing and should do it well.
This sounds straightforward, but, in practice, it's
often tempting to add new functionality onto existing modules
rather than create new modules from scratch.
There are several design patterns that actually
help us enforce or improve our code's ability
to adhere to the single responsibility principle as well.
The first is the strategy pattern, which drives us
towards having small, independent algorithms.
The command pattern helps us to abstract the actions an object takes
from its internal implementation.
Finally, the state pattern helps us to abstract away
how an object behaves in different states that
can change dynamically at runtime.
While the single responsibility principle
might seem to drive us to have large numbers of classes,
these classes are easier to understand, extend, and repair,
which, generally, makes program evolution an easier and more amenable
task.
So let's take a concrete look at the single responsibility principle
as it applies to Mario.
So let's think about how Mario would evolve if we
started to write the game from scratch.
Now, the level class seems like a great place to begin.
So level, if we recall, has the ability to move Mario.
It has the ability to update, to control the game loop,
and the ability to render the scene.
These were the first three features that level had.
Over time, though, we kept adding new features to the game.
We wanted Mario to be able to hit an enemy, so we added hit.
And then we realized we wanted to have a score,
and we wanted to keep track of the time, so we added those features too.
And once we had those, we realized we wanted
to be able to pause and resume the game, and we wanted to be the load
and save the game.
So we added all of these features.
And, finally, we realized it was kind of quiet playing Mario,
so we wanted to have sound and music.
But we wanted to be able to turn the volumes up and down
on those different parameters as well.
And all of these features just ended up naturally going into level.
Level existed.
It had all of the data we needed, so we just kept adding it there.
But that ended up violating the single responsibility principle,
because level now does all kinds of different things.
So how could we refactor level to make it
better adhere to the single responsibility principle?
So the first thing we might want to do is add a Mario class.
Level doesn't need to keep track of everything.
So let's pull out Mario and Mario's ability to move and hit other figures.
We'll pull those out.
So now we have a Mario class that has move and hit.
The next thing we want to do is take a look
at what other features make sense together.
The first that stands out for me is this notion of a game frame.
So the frame is what shows the score and shows how much time the time remains.
So let's pull those out and put them in their own class as well.
So taking a look at level again, we can see
there are features around game saving and loading.
And those sound like they're the same type of feature.
So we can create a new class called game persistence that
just has a save and a load method.
And that helps us to pull them out of level as well.
And, finally, we have things that are really related to gameplay itself.
So here we can create a game engine class that has pause
and resume, and sound level and music level.
So we can change those dynamic game properties in the game engine class.
So where does that leave us with level now that we've extracted out
all of these other features that weren't really core to the level functionality
itself?
Well, we still have update and render.
Those methods are the same.
And we've changed from a move method to input method.
And this you'll recall from our earlier discussion around the sequence
diagrams.
And other classes that we've created also all
adhere to the single responsibility principle.
They're responsible for these specific actions within the game.
And it makes it easier as a developer to just look at these classes
and understand where different features and bug fixes should occur.