
REID HOLMES: Deployment diagrams overlay class diagrams
to add additional information about where the various classes and modules
will exist at runtime.
These are particularly useful in distributed and Cloud-based
applications.
One nice thing about deployment diagrams is
they give key stakeholders a nice document
that they can use to concretely talk about execution environments.
For instance, the developers can talk with DevOps and infrastructure teams
to make sure that the environments that they need to run their software
will be in place when they go to deploy.
It also helps the DevOps and infrastructure
teams to plan so they know what's coming in the future,
and it enables them to get their environments ready.
While deployment diagrams might seem simple for small applications--
for instance, if you just have a client and server--
in sophisticated applications where we have multiple different Cloud services
or sets of virtual machines running in a large distributed environment,
the deployment diagram can provide crucial information
about the overall architecture of the system.
This is the UML diagram for Mario that we've been using so far.
So if we wanted to go and add information about the execution context
for this game, what would we have to do?
Well, if we think about this-- think about it-- all of this
runs in the user's browser.
So making this into a deployment diagram is really quite easy.
All we need to do is add a box around all of these classes
and add a specialization that captures where this execution happens--
which, in this case, is the user's browser.

And that's all there is to it.
So here we can tell, now, from the class diagram,
that everything runs within the user's browser.
So what would happen if we wanted to modify
Mario to be a multiplayer game that was played across the network?
How would we capture that?
What would we have to do?
Well, let's take a look at that now.
There are several different designs that would work here,
but let's just take a look at one of them.
So the first thing we might do is just have a remote notion of a level server.

And what the level server is going to do is
it's going to keep track of all of the things happening
within the remote levels of anyone who's playing on a session together.
Now, if we're playing a multiplayer game,
we probably also need some notion of a leaderboard.

And the level server is going to communicate
with that leaderboard to keep track of who's winning,
or who's won the most games, and what their scores have been.
Of course, as soon as you have a leaderboard,
you also need some notion of an account so you
can keep track of who should be on the leaderboard itself.

And these will be our three main components that exist on the server.
Now that we have these three new classes,
we need to figure out where they're actually going to execute at runtime.
And for this design, what we've decided is that they will run on the server.
So we can capture that, again, in the deployment diagram.

Now, the next step that we need to figure out
is, how are we going to actually wire up the browser and the server?
How is this communication actually going to work?
And that's the next thing we need to figure out.
So where should this communication be?
On one hand, it would make sense to have the level server talk to level.
But then you're going to add a whole bunch of extra concerns
to level that are dealing with network communication.
So what we'll do instead is we'll add an intermediary on the client side that
knows about how to deal with the network itself,
and then we'll have that communicate with the level server directly.
Now we have this network piece that acts analogously to input, right?
Really what this is doing is it's providing another means
to get input into level.
And what we'll do is we'll wire up network to level server.
And we want to add a little bit more information about this communication,
so we can also say that they will communicate over WebSockets.

And in this way, we're able to capture the high-level deployment
of this full multiplayer version of Mario.
So we have this piece that runs in the browser--
which, other than the network, is relatively self-contained--
and then we have the server piece with this level server
that keeps track of a session of a game that's happening,
and the leader board and account manager.
A nice thing about this design as well, though,
is the browser-based version can still exist in single player mode
by simply not using the network.
So we can see that this is a relatively straightforward to support
both single player and multiplayer.