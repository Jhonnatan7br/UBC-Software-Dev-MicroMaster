
GREGOR KICZALES: In this video, I'm going to design another function
operating on Element.
We learned that element and list development
are mutually referential types.
And so that means designing one function is actually
going to end up designing two of them.
I'm in FS dash 2 V2 dot racket.
And if I scroll down here to the problem, here it is.
Design a function that consumes Element and produces
a list of the names of all the elements in the tree.
So I know right away it consumes Element.
And I need to know what list of names means.
So I'll go back up to the Element data definition.
And let's see, for an element, the name is a string.

So this is going to produce list of string.
And, of course, they'll be the function that operates on list of element.
And that's almost certainly going to produce list of string as well.
Let's do a purpose-- produce a list of the names
of all the elements in the tree.
We'll do a couple stubs-- all names dash dash element,
which consumes e produces empty.
And all names dash dash loe, which consumes an loe produces empty also.
So those are the stubs.

One, make sure they sure they're well formed.
They are.
There's no test, so they're not running.
So they're highlighted in black.
OK, let's do some examples-- check expect all names dash dash-- now
which ones should I test first?
Let's go look at the type comment.

Up here at the type comments, what we're looking for is what is the base case.
Remember, the base case is a place where the reference cycles stop.
It wasn't here in Element, because the only thing that happens in Element
is make alt of these three fields.
And list development is a reference to list develop.
So let's look in here for the base case.
Well, here we see that the base case is operating on an empty list development.
Because this isn't the base case, the cons case
isn't the base case, that goes in a cycle to list development,
and it also goes back up to element.
So empty list development is the base case.
So now we can go back down to where working.
And we're not that to test the base case first,
we're going to start with all names dash loe of empty.
What is all names of an empty list of elements produce?
Well, that sounds like empty.
We're still not quite certain that this function
is supposed to produce list of string.
But assuming it is for now, it would clearly produce empty in this case.
Let's do another case.
We've done the base case.
But let's also try to do a simple case now.
And what I'm going to do is go back up here and get this figure
and copy it down here.
It's really great that DrRacket lets you do this.
You should enjoy it now because not every programming
environment will let you do it.
So we've tested the empty list of elements case.
Let's now check all names dash element of let's check F1.

Well, what are all these elements in the tree starting at F1?
Well, it's just F1, because F1 has no sub-elements.
So all the names are list F1.

Let's check another case.
Let's check all of the names in D4.
Well, what are all the elements in D4?
Well, there's D4, F1, and F2.
So those are the names-- D4, F1, and F2.
Let's do another one.
So we've done F1.
There's no use doing F2 or F3, because they're the same as F1.
There's really no use doing D5, because D5 is simpler than D4.
Except maybe we should have done D5 first because it's simpler than D4,
not much simpler, but it seems a little simpler.
So let's do it.
And it would produce-- what would it produce?
Well, it would produce D5 as the first thing and F3 as the second.
Now, what's D6 going to produce?
Well, let's see, D6-- well, D6 has D6 in it for sure.

Well, what else does it have in it?
Well, it has everything in D4, which is all of that, and everything in D5,
which is all of that.

Well, let's see, these two list have to combined
in that has to be put on the front.
So one way of saying that is appending those two this together and causing
that single item on the front.
You could, of course, just write the value.
You wouldn't have to write the elaboration.
So you could just write-- just write it this way.
But the elaboration might be helpful, especially for case a little bit
complicated like that.

OK, let's run it.
All names dash element is not defined.
Oh, I didn't follow my naming convention properly.
And since I cut and pasted, I didn't follow my naming convention properly
several times.

OK, the tests are all well formed.
Let's save this.
It's always good to save often.
OK, so let's comment out the stubs.
And let's go get the templates.
And I'll show you a trick here.
If you go right here, you get a list of every definition in the file.
So as files start to get bigger, you can jump to individual definitions
more quickly this way.
And all good programming environments give you a feature like this.
So I'll go to fund for element.
And I'll grab the two templates.
And I'll go back down where we were.

And I'll get rid of these comments.
I'll do the renaming.
Remember, there's mutual recursion here, so I
have to be careful to get all the references.
There's that one.
And then there's this natural mutual recursion here.
And then when I rename the loe function there's the definition.
There's the natural recursion.
And there's the natural mutual recursion.
So I get all those.
So now, let's work off the examples.
The first example tells me that if I call names loe with empty I get empty.

The second example tells me that I call names dash dash element in F1,
I get F1.

Let's see, in that particular case, this would be F1.

And what would this natural mutual recursion be?
Remember, I'm reluctant to delete natural recursions
or natural mutual recursions.
Well, it would be all names dash dash loe empty, because F1 has no subs.
And we already know that's going to produce empty.
And that seems kind of natural-- seems natural to just cons F1
onto the natural recursion.
That's also what is very complicated example
was suggesting to us was that you would cons
the first thing onto the recursion.
At this point, it's really clear that this
function-- the one that consumes list development-- has
to produce list of strings.
So I'll get rid of that set of question marks.
And I might even do this.
Let me get rid of this note.
Let's see, I'm almost done.
I just have this case.
This is a case where all names loe is called with a list of elements
that isn't empty.
We don't exactly have that case.
Let's put that case in here.

So let's say it's called with D4 and D5.

Well, what's it supposed to produce?
Well, it's got to produce everything in D4 and everything in D5
combined into a single list.
And again, the way you combine two lists is with append.

So that suggests that this should be append.

Let's try running it.
Check expect expects two arguments but found only one.
It's telling them that this is the whole check expect.
So that's not right.
I've got an extra parenthesis there.
And whenever you have an extra parenthesis there,
you almost surely are missing one a little farther along.
There.
Now let's try it.
One of the test failed-- D4, F1, F2.
So this produced-- I'm just going to grab what it produced here.
Actually, because I've got my screen small for recording,
I have to be a little bit careful here.
I'll slide this down here.
I'll click here to see what test it is.
I'll reselect this.
So in this test for D4, D5, it produced--
oh, I have them in the wrong order.
I just have my test examples in the wrong order.
Because I asked D4 and D5, but over here I put the order 5, 4.

Let's save it and run it.
All 12 tests pass.
Let's look at the whole function again with the weakest figure.
Again, this was almost entirely following the
How to Design Functions Recipe that we've
come to understand quite well now.
The only wrinkle that came in because of the mutually referential types
was that we had to design two functions.
We had to think a little bit about what was going to be the base case test
and used a naming convention to have two functions of different names
that operated on the mutually referential types.
That's really about it.
This is mostly an ordinary How to Design Functions problem
with more complicated data.
