
GREGOR KICZALES: In this video, I'm going to design one more function
operating on arbitrary arity trees.
So much of this will be familiar.
But the design of this function introduces a new and important concept
called backtracking search.
So let's go find the problem.
It's in FS-V3.racket.

And we'll scroll down here.
And we're supposed to design a function that consumes string and element.
Let me write that down-- string element-- and looks for a data element
with the given name.
If it finds that element, it produces the data.
Otherwise, it produces false.
It produces the data.
Let's see what that means.
So I'm looking in one of these trees for an element with a given name.
Oh, right, the string is the name.
So that's why I got the string as an argument.
I'm looking for an element with the name equal to the string I was given.
And if I find it, I produce the data, which is an integer.
So going back down here to where we were,
we're going to produce integer if we find it.
And otherwise, we produce false.
So that's different.
That's something we've never done before.
What's happening here is this function is going to go look
for an element with the given name.
And sometimes it's going to produce the data.
Otherwise, it's going to produce false.
We've written functions that say whether a given string is in a list of string.
But that function always produces a Boolean true or false.
Here, we're going to produce the data if we find it, or false otherwise.
And so we need a little extension to how we
write function signatures to do this.
And what you're going to do is you're going
to say whatever type it would produce if it succeeds, or false.
So this is a special form of signature that's
particularly applicable to backtracking search.

Now, in some programming languages-- in most recent programming languages--
there's a more sophisticated mechanism called exceptions
for dealing with this kind of case.
To keep BSL simple, BSL doesn't have exceptions.
But the basic way we're doing backtracking here
can easily be adapted to a language that does have exceptions.
So let's see.
Search the given tree for an element with the given name,
produce data if found false otherwise.
Let's do some stubs.
We're operating on two mutually referential types.
So there's going to be two functions.
Define find--element, which will consume an element.
But it will also consume a name-- some string.
And for the stub, we'll just assume it always fails.
It'll produce false.
And define find--listofelement, which will consume a list of element.
But it will also consume the name that it's looking for, false.

OK, so those are the stubs.
And we should put the signature for the second function list of element string,
and list of element.
And, again, we never quite know here for sure.
But let's put integer or false.
