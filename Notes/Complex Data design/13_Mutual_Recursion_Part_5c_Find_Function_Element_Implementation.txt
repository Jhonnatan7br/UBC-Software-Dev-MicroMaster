
OK.
Now let's see.
You start with the base case example.
If we find loe empty, that's false.
That puts a false here, which of course, make sense.
If you're looking for something and nothing, you can't find it.
Now here's a case that says if we're looking for F3 and F1,
we don't find it.
If we're looking for F3 and F3, we do find it.
So it seems like that when we're looking at element, there's kind of two cases.
This is the case where we find it right away.
Right there and right there we find it right away in those two cases.

And then there's the case what we don't find it right away.
So that suggests an if in [find-  - element].

And the question is, is the name of this current element
the name that we're looking for?
So both names are a string.
This nice little note here that it put in the template reminds of that.

Is the name of this element the name I'm looking for is the question.
One thing about this little note, I put in the template,
in some other kinds of programming languages
and in more sophisticated programming environments,
this would be automatically given to you.
You could just kind of hover here, and it would say, oh,
that's going to produce a string.
So we're just replicating a feature that you might get in some other languages
already.
I like putting it here explicitly to help you understand
kind of where it's really coming from.
We'll delete it now.
So let's see.
If the name of the current element is the name
we're looking for then what are we supposed to do?
Well, we're supposed to produce that element's data.
So there we go.
We'll just produce it's data.
And if the name we're looking for isn't the current element,
well, what are we supposed to do in that case?
Well, these other examples are saying that you keep looking.
We got to go look at all the children.
In other words, we got to do the natural mutual recursion.
And we should follow the standard advice,
which is to trust the natural mutual recursion.
This is going to go look in the children, and whatever it produces
will be the answer.
Now let's go down here.
Now we're looking at a list of elements, and we don't actually
have an example for this.
So let's put in an example for this.
Let's say check.
I'm going to put it right here, because it's really a little bit simpler
than the D4 example.
I'm going to say [find - - elemet loe  (cons F1 empty F2)].

This is the subs of D4 four.
This is the subs of D4.
So actually, I'm not putting this in the right place.
I should really be putting this up here.
This is the subs of D4, and I'm finding--
what do I want to find in there?
Let's say I want to find F2.

Can I find F2 in there?
Yes.
That should produce F2.
And we'll add another one.
Can I find F3 in there?
And the answer to that is false.

Now I can really understand that these examples all have a bit more structure.
There's really the base case example.
There's the has no children examples, where we're looking in F.
We're not looking in anything that has children.
And then this example here is it quite similar example,
because I'm moving it up here now, because it's really
an immediate success example.
This doesn't go look in the children.
So we look in nothing.
We look in things that have no children.
We don't look in the children.
Here we look in lists of children, and now we
start looking in thing where we have to look at the element
itself and its children.
So now I've got the examples ordered more in terms of their complexity,
and so [find - - loe] is really kind of here and here.