
{
  "summary": "Introduces built-in abstract list functions (map, filter, foldr, etc.), demonstrating their use to simplify code, improve efficiency, and reduce the need for base-case testing in Racket.",
  "keywords": ["abstract functions", "built-in functions", "list processing", "map", "filter", "foldr", "Racket", "functional programming", "code conciseness", "testing"]
}

GREGOR KICZALES: The abstract functions we've designed so far seem very useful.
Lots of list functions feel like map2 or filter2.
In fact, map and filter are so useful that they're built
into the intermediate student language.
It provides them as what are called "built-in abstract list functions."
And, in fact, it provides several more built-in abstract list functions.
In this video, what I want to talk about is
how you can use these built-in abstract functions when you're
coding one of your own functions.
So we'll look at how to decide which built-in function is
appropriate in a given situation and then how to set yourself up
to use it properly.
I'm in the using built-ins starter.racket file.
And this file just starts out defining some useful data
and functions that will let us have more interesting examples below.
And now I just want to talk about what some
of these built-in abstract functions are.
You can get a list of all the built-in abstract functions
by going to the course website, going to the Language page, which you can always
select from here, going to the end of the Language page.
And here's a list of all the built-in abstract functions.
For example, the third one in the list is map, which
was the first abstract function we did.
And it's got its signature, its more than one-line purpose-- hmm--
and the header, which allows them to name the parameters
and write the purpose more concisely.
Let's jump back over to Racket and see some of these functions in action.
I've got some check-expects here to demonstrate them.
And what I'm going to do is run them.
Now there's going to be a couple failing tests.
But those are actually from farther down in the file.
These check-expects here are working.
And I'm actually going to also demo them down here,
just to drive home what's happening.
So I'll take this and copy it and go down into the interactions area.
And if I map the predicate positive over a list of numbers,
well, I get back the result of calling positive with each
of those numbers, which, in this case, is "true false true false."
If, on the other hand, I use filter with negative,
I get only the negative numbers-- -2 and -4.

There's an abstract function we didn't abstract before.
But I think you'll see what it is pretty quickly.
This is foldr.
And if I call foldr with + 0 and the list 1 2 3, I get 6.
foldr is the abstraction of sum and product.
+ is the combination.
0 is the base-case result. And that's the list that it operates on.
The way to think about it is that foldr is filling in the ordinary template
for operating on a list of X. So foldr, in some sense,
is the abstract function for the list of X template.
And we can use it in other kinds of ways.
For example, here, we're doing the product function that we did before.
Now build-list is one we haven't seen before.
Let's jump over to its documentation.
What it says about build-list is that it consumes
a natural number and a function which itself consumes a natural number
and produces X. And this function produces a list of those Xs.
And what it does is it calls the function,
it produces a list of calling the function on 0, dot, dot, dot,
all the way up to calling the function on -n1.
Let me show you that more concretely.
I need to tell you first that there's this funny function in Racket which
was made pretty much exclusively to use with build-list
and some other abstract functions.
This function is called "identity."
And all identity does is, whatever you give it as an argument,
it gives you back.
So it's the identity function.
It produces its argument.
If I use identity with build-list-- let's say I say "build-list"
of 3 and "identity," I get "list 9 1 2."
Because look-- what's it doing?
It's calling identity on 0.
It's calling identity on 1.
It's calling identity on 2, and it's stopping there, because 2 is 3 minus 1.
And it's making a list of those results.
Here's another one.
If I say "build-list" square on 4, I'll get-- oh,
I got the arguments backwards.
"build-list 4" on square.
I get 0, which is the square of 0, 1, which is the square of 1,
4, which is the square of 2, and 9, which is the square of 3.
build-list is a funny thing.
We'll see why we want to use it, a little bit later.
Here's some problems that are all of the same form.
They've all got the beginning of a function design.
And they're at the template code the body stage.
And what I'm going to show you how to do is
how to recognize that this is a case where
you could code the body by calling a built-in abstract function.
The basic trick is to first kind of get the insight-- hey,
you know, this feels like it's a fairly generic operation on a list.
Maybe there's a built-in abstract function.
I wonder which one it is.
Then, after a while, you pretty good at doing it just kind of automatically.
But until then, the way to do is to compare
the signature of the function you're trying to design-- here,
it's listof image to listof image-- to the signatures
of the built-in abstract functions, which I've got here,
minus their function arguments.
So now I'm taking away the function argument.
And so what I'm going to do is compare listof image
to listof image to these signatures.
Well, it doesn't match the first one.
It doesn't match build-list, because that consumes natural.
It matches both of the next two, because listof image to listof image
matches listof X to listof X. And it also matches listof X to listof Y,
because, remember, X and Y don't have to be different.
They just "can" be different.

And it doesn't match any of the remaining ones,
because listof image sure as heck isn't Boolean,
and the last two functions take two arguments.
So it's either filter or map.
And, in this case, of course, it's filter,
because this is filtering behavior.
We're potentially producing fewer elements in the result list
than in the consumed list.
That's what filter does.
Map always produces one element in the result list
for each element in the consumed list.
So this is a filter.
And the way we're going to template it is like this.
We're going to say, hey, this is a filter.
I won't know what argument to pass it, here, but I do know it gets the list,
here.
Now this is the template.

Now at this point in the course, you don't really, for your own purposes,
need to save the template.
Templating is starting to become something
that you understand the structure of.
If you can write down quickly, you write it and go.
Or you copy it from a data definition.
I'm going to leave it here, just for your purposes,
so you can understand what we did here today, in this video.
Let me copy it.

And now I'll comment that one out.
And now you have to, as usual, fill in the dots.
And the question is, what is the predicate that we pass to filter?
Again, if I go look at the complete signature for filter,
its first argument is a function that consumes X and produces Boolean.
Its second argument is a list of X, and its result is a list of X.
So this needs to be a predicate, here.
It needs to be a predicate that consumes X.
Now, you may not remember this, because it went by quickly.
But at the top of this file, there's a predicate
called "wide?" which consumes an image, which is what X is in this case,
and produces a Boolean.
And it produces True if the image is wide.
So this is what we want.
We'll go back down to wide-only.
And we'll just put "wide?" in there.
And one of the things that's nice about using built-in abstract functions
is that your function definitions get really short.
And they get really short.
They get so short that you might even be tempted to write them on one line.

The book sometimes calls that a one-liner.
But let me note that what it means to be a one-liner is that it's very short.
So that's really, still, for all intents and purposes, a one-liner.
It's very short, it's very simple, because we
used the built-in abstract function.
And let me make one more point, here, about the benefit of using
the built-in abstract functions.
It's already up here, above, but you might not have noticed it before.
Notice that I don't have a base-case test here.
And the reason I don't have a base-case test
is that the built-in abstract functions are already thoroughly tested.
I know that their base-case behavior is going to be correct.
So I don't really need the base-case test
for the built-in abstract functions.
So when you use one of them, you don't have
to follow the normal rule about starting with a base-case test.
Let me do another one quickly.
listof image to Boolean.
"are all the images in loi tall?"
And I'm asking "are all the images in loi1 tall?"
Let's go look at what LOI1 is.

LOI1 has all these rectangles in it, so they're clearly not all tall.
On the other hand, let's see.
If I just took one and three, they would all be tall.
So let me go back down there and add that as a second test.

So now I've improved the setup a bit.
And the question is, which built-in abstract this function is this?
Let's see.
I consume a list of image, I produce a Boolean,
I take the abstract list functions' signatures,
I remove their function argument.
Which one matches?
Well, it's andmap or ormap.
And if I go to the Language page and look
at the description of andmap and ormap, andmap
says "produce true if p produces true for every element of lox,"
whereas or is for some element of lox.
And, unsurprisingly, I probably could have done this without looking here.
But, since this purpose is "are all the images in loi tall,"
this is going to be an andmap.
So I'll say "define all-tall loi andmap ...
loi."
And this time I'm not even going to preserve the template.
I'll just have briefly this template stage.
And now I have to decide, what goes in the andmap.
And, of course, it's the predicate.

"tall?"
Let's see.
That test is passing.
The first failing test is after that.
First failing test is sum.
I'm going to let you do sum as an exercise, now.
And I want you to go through the whole process I've just shown.
Compare the signature of sum to the signature all the other functions.
I'm going to give you a hint, here, though.
I do want you to compare the process.
But I am going to give you a hint, here, which
is that the function you're looking for is foldr.
So go ahead and do this as an exercise.
And when we come back, I'll do the last one.
