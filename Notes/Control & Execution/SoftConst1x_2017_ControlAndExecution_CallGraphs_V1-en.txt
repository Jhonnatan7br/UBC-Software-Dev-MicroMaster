
ELISA BANIASSAD: Another thing we can do to understand the system is understand
its overall behavior.
So we already understand the basic structure of it
and now we can kind of start to surf around using some of the tools
that we've used figuring out what calls what
and building a picture of how the whole program works.
We can do this without a ton of Java knowledge too, actually.
We just need a couple of syntax elements and some IDE shortcuts.
So first, classes, we need to remember that a class is
a file with all of the data and behavior for one concept.
So if you look inside the class, you'll see all its methods.
Second, method calls, to look at methods call each other,
we want a really clear idea of what a method call actually looks like,
and here we can see some.
We have a word, and then we have open and closed round brackets.
Sometimes there are parameters inside these little round brackets,
like right here.
Next, we want to know how to move from a method call
to the definition of the method.
So you can get from a call to the definition by hitting Command-B,
just like we did when we were surfing around for the imports.
So here we see select and place shapes and we
can press Command-B to get to its definition,
and then we can go back with command or control left square bracket.
So, actually, to see all these keyboard short cuts,
you can just click the navigate in the top bar
and that'll tell you all of them.
So I just want to make really clear there are actually
two kinds of method calls in Java.
Some are calls within a class, and we can see those
if we go to select and play shapes that were still in the same file.
We haven't left the drawing player.
But then there are also calls that are to different classes.
So those live in a different file and they
look like this, they have some kind of name in front of them,
this is the variable, and then they have a dot called the dot operator,
and then they have the name of the method and the parameters,
if there are any.
We can still use Command-B to see the declaration.
But this time we move to a different file, the one in which it's declared,
which in this case is drawing.
So finally, let's take a look at a real method.
In this action perform method, we can see that a whole bunch of things
are happening, a lot of calls are being made.
Now, we're going to talk later about how these calls are actually made
and how the code actually runs and the order in which it runs
and how parameters are passed, et cetera.
But for right now, we're not going to worry about most of that.
Right now, we just want to be able to recognize what a method
declaration, basically, looks like that has a name and a parameter list
and that has a whole bunch of code sitting inside these curly braces that
implements the method.
Great, now we're ready to go.
Once again, we're going to start looking at our program
from the class with the play symbol, just like we did when we first
walked up to the system, and this time we
want to specifically look at this main method.
If a close has a main method, then you can run the class.
If you don't have a main method in the class, then you can't run it.
Sometimes several classes actually have a main method,
but there's usually one predominant one that lets
you kind of launch the whole system.
But in this case, we only have one inside the drawing editor class.
So now we're going to bring up the structure of that class
so we can jump to the methods declaration,
and then we can follow it and see where it goes, and while we're following it,
we're going to build something called a call graph,
which means a view of what calls what inside the program.
This is often a partial view.
This one certainly will be.
Complete call graphs are actually really huge for anything
beyond a small program, but we're using this kind of model
to be able to help us reason about the program
so we just keep track of what we need to.
So now we're going to use Command-B to build up
our picture of what calls what.
So the first part of the picture is that main calls this drawing editor method,
then we bounce over here and we see that it makes several calls.
So we'll add them to our picture, and we can command B into those calls,
as well, to build up our picture even further.
So the first call is something called super,
which is a weird looking name and it's kind of strangely highlighted,
and if we Command-B into it, it takes us somewhere with an entirely different
name, which seems quite confusing.
But what we can actually see is that we've delved deeper into Java itself.
So we're going to go back, because we've navigated
outside the bounds of our own project.
Note that this will not always be true of calls to super.
You can have a called to super that ends you up in your own code,
but in this case, we go to Java.
So now let's look inside of initialize fields and see where it goes.
Initialized fields does three things and the only one that's
actually a method called is this call to new array list tool.
But that, once again, takes us into Java so we're not going to look any deeper.
When we're building up our call graphs, we usually
don't care about anything that's outside of our own package structure.
So we might put the name of the method that we've called onto the call graph
just to kind of record that it's there or sometimes we might skip it,
because we're really interested in how our program works together internally,
and maybe sometimes we are less concerned
about how it uses the Java libraries.
So next we look inside of initialized graphics, which does a bunch of things,
and we can infer what they are just from reading the method names.
We don't have to understand the code really,
because the names tell us so much.
So it clearly sets the layout, the minimum size, creates some tools,
adds a new drawing, sets visible to true,
and basically a lot of initialization stuff.
Great, so we have this visualization of our call graph.
We haven't chased down absolutely everything,
obviously, but we have a decent idea of what's going on when we run main.
When we run main, it calls the drawing editor,
does a whole bunch of initialization, including initializing all
the graphics, and makes them visible.
OK, great.
So this tells us a lot about how the project is launched
and after initialized graphics runs, the Java framework takes over and actually
displays everything.
So you don't have to know exactly how that works.
In software we sometimes refer to this as magic or things
that happen auto magically, because we know that it works,
but at our level of abstraction, we don't really need to know how.
So that was going forward from the main method,
but what happens when a user interacts with the system?
Well, there are methods that handle each of these interactions
and we can explore those too, so for instance, the mouse
pressed in drawing area method that obviously handles
user interaction from the mouse.
Again, there's an element of magic here.
This is similar to what happens with the big bang on mouse function.
The framework or Java basically makes a call into your code,
and then that's what's run in response to stuff like mouse clicks.
So let's build a call graph starting from here to explore its functionality.
The first thing it does is call new shape.
And if we go into that method, we can see
new shape doesn't call a lot of important things,
just get X and get Y from point.
And then we can jump back and look at the call to editor
get MIDI synth, which just returns a MIDI synth.
And then it makes these three calls, select and play, get bounds,
add to drawing.
And I know, because I've already done this,
that set bounds doesn't do anything, so we're not going to follow that one,
but select and play has more going on, so we'll follow that branch.
So here we can see that it calls play, which calls MIDI synth.play, which
calls get channel data, and then get channel data does
a whole bunch of other stuff, including get specialized channel,
which just return something.
So we can keep following and walking this tree of calls
and eventually we form our entire call graph from our starting point,
and that's normally how we use call graphs.
We just started a method and we make an entire call graph down from there
until we hit Java, and that's how we know
that we've conceptualized the entirety of a particular behavior
starting at a particular point.