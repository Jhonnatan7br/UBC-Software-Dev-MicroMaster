
ELISA BANIASSAD: OK.
So now, I have to take a little sidebar and tell you about something that you
wouldn't have seen in BSL in this form.
And that is variables.
So variables are, you've probably seen them in math, like you can have x,
and x's value can vary in different uses of a function.
And that's kind of the same here.
You can set up a symbol that holds a value.
So in Java, for instance, you would have a symbol
that would hold a particular value.
Now, in Java, and in imperative programs in general,
these little holders can come in many different shapes and sizes.
And in BSL, they also came in many shapes and sizes.
Like they can be numbers or strings or lists or whatever.
But you didn't have to decide for yourself.
BSL would kind of figure out using its dynamic type system exactly what
size and shape this thing should be.
But that's not true in Java.
So in Java, you have to do something called declaring a variable.
You have to tell Java what type of thing is going to be put inside that holder.
So here, if we want to store numbers in here,
we can use this sort of small type called int.
And int is just basically a number.
And we can say int x.
And that declares us the symbol x and promises that we'll
be storing ints inside of this holder.
And you don't just have to declare types that are primitive to Java.
You can also use types that you've designed yourself, like dog.
So we can say dog d.
And dog d will make a d.
And it will make a little holder for a d.
But it doesn't put the whole dog inside of its little holder space.
Instead, what it puts is an arrow that's going to point to an instance of a dog.
So now, we have declared our variables for x and d.
And we have our holders in place.
But these holders have no actual contents yet.
So how do we get actual values to sit inside of these holders?
To do that, we use something called an assignment statement.
So we assign value to these symbols.
So to assign a value to an int, we can just say x equals something like 3.
And an int is a primitive Java type, which
means that its value can sit right inside of the holder.
So it would just sit right in there and exist as a 3.
And objects are a little bit different.
They don't hold their value right inside of here.
Like I said before, instead they hold a reference to an instance of something.
So when we define d, we said OK this thing is going to hold a reference.
And now we can assign a value to this reference
to say which instance it's supposed to be pointing to.
So let's imagine that we don't yet have a reference.
What we would do is we would say d equals new dog.
Sorry.
And this new dog call, of course, is the call
to the constructor that looks in the Dog class.
And just all the construction work, it allocates all the memory.
It does all the construction work.
And it gets the instance set up.
That's this half.
The assignment actually takes this value, this location
and puts it in here.
So the assignment is what gets this value routed
to this particular instance.
And it's not just that we have a new dog.
We don't always have to have a new dog.
For instance, we could define a second dog.
We could declare a second dog, dog Fido.
And that would get us a variable called Fido.
And this would, of course, have to store something that points to a dog.
And then we could assign Fido to point to the same instance as d points to.
So we could say Fido equals d.
And it doesn't copy this whole thing.
That's not what it does at all.
It just looks at the value that lives here
and copies that value down to here.
So now, Fido would also point to the same dog instance.
So now that we have d and Fido, we can use this object.
We have these two references to this object.
Now we can use this object to execute operations.
And we can change its data.
So we can say things like d.bark.

And d.bark will look in d, find the bark method, and run the bark method.
So it would go woof woof or whatever the definition of this method is.
And we can also change the name of d.
So we can say d.name.

Of course, this is just another variable.
So it also just has a slot that sits right here.
So we can assign it a value as well.
So we can say d.name equals, let's say, Jim, for some reason.
And that would look for the reference d.
And it would come over here, and it would say Jim.
And then we might also want to assign it a name using
the Fido variable that accesses it.
So we can say Fido.name equals Fido.
And believe it or not, that will then come and find the same object.
And instead of having Jim in here, we would have Fido.
So it would change it in the same spot.
So there's another really useful type of thing that we are going to use a lot.
And that's actually something that you're really familiar with from BSL.
And that is a list.
So I'm just going to quickly, within my little sidebar,
take a moment to show you how lists work.
So once again, lists are objects or classes
that can be made into objects, just like most everything in Java.
So we want to first declare a list.
So we'll say array list.
Sorry about the squeaking.
And then you have to say what kind of list it's going to be.
So what is the list going to actually hold?
And in this case, our list is going to hold a series of dogs.
And so this is the type of list that it is.
And now, we're going to give it a name.
And that's going to be something meaningful, like dogs.
And of course, you can call it whatever you want.
But I'm just calling it dogs.
And that gets us a declaration.
So that gets us dogs with a little box that's going
to be a pointer to something like this.
So this is going to point to something.
It doesn't point to anything yet.
We've only declared it.
Now, we have to actually make one.
So we will say equals because, remember, we
can put the declaration on the left hand and do the assignment
of the instantiation on the right.
We can merge basically these two lines of code into one line of code.
So we're saying array list dog.
We get the declaration.
And then we say equals new array list of dog.

And this is a constructor.
This is a call to the constructor of a type that matches this one.
In fact, this is optional.
Java will work out that if you leave this empty that you meant that.
But we're going to put it in just because it's
nice to have them match up.
And also Java does allow you to put them in.
So array list dogs equals new array list dog.
And this part constructs you an array list.
So it gives you a block of contiguous memory.
And each one of these buckets is going to hold a reference to a dog instance.
Once again, the dog instance will not sit inside the bucket.
It points to a dog instance.
So each of these is going to point up to a dog, just like this points
to an array list.
And this assignment operator actually did that mapping.
So now, we come over here, and we have a reference now
to this particular instance of an array list.
And now that we have a reference to our array list, we can actually use it.
So we can put dogs into our array list of dogs.
So we can say dogs.add.

Because, remember, this is an object.
And objects often have a ton of useful operations inside of them.
So this dog only has bark in our design.
But array list, if you look at the Java API has tons of stuff.
It has contains, remove, tons and tons of things.
So we're going to use the Add method in this array list to say dogs.add.
And then we're going to add our little dog, d,
that we have instantiated from before.
And what that's going to do is it's going
to copy the value that's held inside of d over into the array list.
So it's not going to take the entire instance and smoosh it into here.
Instead, it's going to copy the value that lives inside of d,
and it's going to copy it down so that lives here too,
just like we did with Fido.
And now, this particular dog points to this dog instance.