
REID HOLMES: When our test suites fail, we
want to be able to quickly and easily isolate
the cause of the failure in the code itself.
So if we make a small change to our code, and it causes dozens of tests
to fail, it can be hard to understand what's going on.
Conversely, if a single test fails, but that test
executes hundreds or thousands of lines of code,
it can also be really hard to figure out which subpiece of that code
caused the failure.
So in isolateability, what we're really trying to do
is we're trying to refactor a system in a way
where we can think a little bit more clearly about what a test failure means
in practice.
The most common way to address isolateability and practice
is to split up the most complicated bits of our system
into smaller, more manageable units, and then test these independently
Of course, we'll still have to test the parts of the system that
use those subparts, but we commonly relax the notion of isolateability
in the case where all the subparts of a larger method are also directly tested.
So let's take a look at a concrete example
from the level class within Mario.