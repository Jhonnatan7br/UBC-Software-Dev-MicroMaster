
REID HOLMES: The extent to which that behaviors in the program
can be verified is known as observability.
So what we want to do is we want to run the code with some known inputs
to trigger a fault. And then when that fault is triggered,
we need to be able to actually see that fault
and validate whether or not it's correct.
So when we're thinking about observability,
one thing that we're doing at the beginning
is going back to the specification and taking a look at the spec, and say,
hey, what actually is the correct value for this state in the program?
And then we need to be able to do is we need to write an assertion that
can validate that state, that can differentiate
between a correct and incorrect behavior.
Now sometimes we were writing our system or when
we're modifying an existing system, we needed to make changes to the code
in order to enhance its observability in practice.
So let's take a look at a concrete example from Mario.
So here we have the set velocity code that we've seen before.
And this is responsible for making sure that Mario [INAUDIBLE]
is facing left or right in the appropriate direction,
depending on the velocity that he's given.
So looking at this code, what we want to do
is we want to test to actually make sure it's correct.
So the test case we may write could look like this.
So we have figure dot setVelocity.

Now, how can we actually test that this is correct?
If we look at the code, we can see that there
is no return type from this method.
So how can we actually do this?
If we look at it, we can see that it's actually
setting a field called this.direction with the direction
that the element is going.
So there is a path for us to write a test.
And it would look like this.
We'd have expect fig.direction.

So here, we've accessed the direction field
within fig, which is unfortunately public.
And we say, to equal.
And we'll compare it to the right constant.

And this is how we could write a test for this code.
Now this doesn't seem that bad.
We were able to invoke the behavior that we cared about.
And we were able to check the value.
But it was unfortunate that fig.direction had to be a public field.
Because whenever possible, of course we want
to maintain information hiding within our code
and make it so that fig.direction field can be private.
So this is really an unfortunate piece of information leakage within our code.
So what we want to do instead is to refactor this
so we can improve the observability of this result
without requiring fig.direction to be public.
OK.
So here we've got a refactored version of setVelocity.
And you can see that between the two versions of the code,
they're almost the same.
This wasn't a complicated refactoring it by any means.
So what we've done is we changed the signature of that velocity.
So it now returns an object of type direction.
And at the very bottom of the method, we've
added a return statement that says return this.direction.
So we're just returning this value so that it can be observed.
So what is this test case look like now?
So if we write it out, we can start all the way
with the expectation from the beginning.
We can say expect fig.setVeloctiy 1, 0.
So we have invoked the behavior.
And we dot to equal direction.right.

So while this looks like a mouthful, it really does read quite naturally.
We have expect figure dot setVelocity to equal direction dot right.
And what this has allowed us to do is write the test in a more compact way.
But it has also allowed us to make it so most importantly,
that this field, this.direction can now be private.
Because the method setVelocity is returning the result of its computation
directly.
And this was this very small change that made both the test easier to write
and allowed us to improve the overall design of our system
by making it so that field could be private in the future.