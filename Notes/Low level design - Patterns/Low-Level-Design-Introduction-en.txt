
REID HOLMES: The solid design principles gave us guidelines
to help us come up with the initial design of our system
and gave us some feedback to avoid poor designs.
But before we can implement these designs,
we need to think about the design at a lower level.
That is instead of thinking about the intent of our design,
we need to move over into a more mechanical space
when we're thinking about how that design will be implemented
by developers once they start coding.
So to do this, we often keep three guidelines in mind,
so that we're able to operationalize that high level design into something
that we can turn directly into code.
The first is that we want to encapsulate what varies.
Next, we want to ensure that we're programming to interfaces.
And finally, we want to favor composition over inheritance.
So let's talk about each of these in turn.
One thing to keep in mind with these low level design guidelines
is there is an incredible amount of overlap with the high level
design principles that we've talked about earlier.
These really are ways to operationalize those high level
principles in practice.
So when we think about encapsulating what varies, what we really want to do
is we want to be designing our system in such a way
that it can be easily extended in the future
and so that bugs that happen within that systems, regressions
that get introduced into our programs are
easy to resolve in semi-localizable spaces, right.
We don't want our bugs to be scattered throughout our system.
In long lived systems, the only constant we can really rely upon
is that our systems will have to change to adapt to future needs.
So when we're designing our systems, we really
want to think about building the appropriate abstractions so
that future developers can add new functionality as easily as possible.
Now it's not just as easy as that, right.
We don't have a crystal ball.
So often it can be really challenging to figure out what kinds of future
needs you're going to have.
And we can't go and build our systems to encompass all possible future needs,
because that makes the system really hard to understand, right.
Unnecessary abstractions are a challenge for future developers
as they try to understand why you built your system the way that you did.
So it's important to take the time to try
to think logically about what kinds of future variations
you want to support without going overboard,
because, again, there is a cost in adding too much abstraction.
Design to interfaces really helps to decouple our implementation
from our design, and this is a core design goal for our systems.
The reason we wanted to do this is we want
to make it so we can reuse parts of our system
without having to worry about the implementations that
underlie those pieces.
So if our code, our classes only depend on other interfaces,
we can reuse just those really thin interface wrappers
without having to worry about all of the implementation details that
underlie them.
The interface definitions for a system define its high level vocabulary,
and by looking at the declarations within those interfaces, the methods,
parameters, and return types, we can understand that collaboration
that take place within the system.
And this is great because it gives us a really succinct way
to understand a system without looking at all the details of it's low level
implementation.
If you only have two developers on a software project,
designing databases might not be that big of a deal, right.
You might only have 50 to 100,000 lines of code that you're trying to manage.
But if you're in a larger team of 50 or 100 or 1,000 developers,
the amount of code that underlies your system
will be so large that this becomes really a key design guideline,
because these interfaces are a great and fundamental way
to succinctly capture your system and ease future reuse.
Favoring composition over inheritance makes our code more dynamic at runtime
and makes it easier to add new features as time goes on.
Now this design guideline is somewhat at odds with many of the design patterns
that we're going to talk about, because design patterns all heavily leverage
inheritance.
At the same time, favoring composition over inheritance
is a nice low level principal that you should really keep in mind,
because it forces you to really reason about do I need to use inheritance here
or can I just get away with composition?
Because composition really is easier to evolve in the future.
The reason for this is that code that is inheritance-based based
is more brittle than code that is composition-based.
This is because subtypes in an inheritance relationship
are more tightly coupled to their super classes
than two classes that are coupled to one another through composition.
And this means if you make a change to the supertype,
it could percolate down and affect all subtypes,
whereas if you have designed your API's well,
classes that are just coupled through composition
are more isolated from one another.
The way composition works is through delegation.
So what you're going to do is you're going
to have an object usually provided from a parameter or a field in a class
and you're going to invoke methods on that object,
and those methods are going to complete work for you.
In contrast in inheritance, what you need to do
is you need to extend an existing class.
And you'll call methods up the super chain.
You'll call super methods to get tasks done.
Now what composition does for you, though, that's
really handy is it drives you towards having much smaller classes, classes
that are much more tightly bound to a specific set of functionality.
So this means that if you want to change behaviors at runtime
you could just point your field to a different object
or you can provide a different parameter and that parameter type will flow in
and you'll make method calls on that.
So that gives you much more flexibility at runtime.
