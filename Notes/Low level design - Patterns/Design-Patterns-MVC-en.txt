
REID HOLMES: Designs often use multiple design patterns together.
And one of the most common form of meta-pattern is actually MVC--
Model View Controller.
What the Model View Controller pattern does
is it tries to separate the view of an application from its implementation.
The reason this is really important is that it turns out in practice,
the views are what change the most.
People will go and they will look at a view.
And they'll have some ideas.
And they'll want to tweak this or change that.
And what MVC does is it makes it easier to independently change
the view from the rest of the system.
Splitting the UI from the business logic also really works in a team
environment, because the people who own the back-end business logic
are often different from the people who own the front-end views.
Also, splitting these views out eases testability,
because how we test the views is often different from how we test our business
logic, both in terms of the frameworks that are used
and the types of techniques that are going to be employed.
Finally, it's often the case that the same back end
logic will be rendered by multiple different kinds of views.
So if you think about some kind of a charting application,
you might have a cell view--
like a spreadsheet of a set of data.
Then you have different kinds of charts that would represent that data as well,
and maybe a tree widget.
So all of these different view widgets will
be rendering the same back-end model.
And this is a really common problem.
Actually, if you think about it in terms of Mario,
you could have the game where the person is playing in 2D.
Or you might have an overview map that's in the corner.
And the underlying model is the same between both of them, right?
The 2D map still needs to know where in the screen
you are in order to draw that thumbnail.
But in the main game view, you're also going to use the same information.
Let's take a look at the three main components within MVC.
Now, the first is the model.
And before we get started, one thing I really want to point out
is that while this is drawn as a single box,
the model actually will contain many, many different types and thousands
upon thousands, or maybe millions of objects.
So this representation that we're going to draw here
is really a simplification.
The model contains all of the data within our application
and knows how to validate its own integrity and how to persist itself--
for instance, by saving itself to disk or inserting itself
into some kind of a database.
Now, one thing that the model really knows nothing about
is how to render itself.
It really is just a data-centric representation.
What's good about this is it means that we
can reuse our model between applications really easily, because it
is domain independent.
So if we have a mobile app that uses the model, we can go and build a website.
Or we can build some other heavyweight application
that all use the same kinds of model objects.
And in that way, these objects are really easy to reuse.
When we implement the model objects within MVC,
they're usually subjects within an observer design pattern.
And we've seen the observer before in a prior course.
Now one really great thing about models is
it forces us to take a step back and really
think about how we can encapsulate the data within our systems
in terms of these domain-independent model objects.
And this is an extremely powerful design exercise,
and is one of the best things about this pattern.
The next part of the MVC pattern is the view.
So the views are what know how to render the model
objects so that a user can see them.
Now, like we mentioned before, the model is the subject in the observer pattern.
And that means that the view itself is the observer.
So whenever the model updates, what it does is it
goes and fires notifying events that come out to the view.

In this way, the view gets to learn about changes
that have happened within the model.
Now, the view won't actually know what's changed.
So what the view will go and do is it will go and call the model object
and ask for its state.

And this is the relationship between the model and the view.
Just like the model box represents all of the different model
objects within our system, the view box is doing the same.
So if you were to think about, for instance,
an IDE that has, for instance, a source code view with some kind of problem
view on the bottom and other outline view on the side,
those would be three different views.
And in almost every MVC-based application,
you're going to have lots of views.
So while we're just showing one here, the power of using the observer here
is that the model can go and notify multiple views
concurrently that it has changed.
And this allows those different views to go and retrieve
the state that's necessary to perform the rendering that
is relevant to the kind of view that they are.
So don't just think about this view box as being a single object.
But it's going to be a whole collection of different views
that might be visible concurrently.
Finally, we have the controller.
Now, it's important to note that the controller is tightly bound to the view
that it's associated with.
So what the controller does is it responds to changes in the view
and updates the model accordingly.

So what the controller is really responsible for
is responding to changes from the view and updating the model accordingly.
So that means that the controller is going
to contain all of the business logic to be
able to respond to actions that arise from users,
and updating the model in the specific way
as is required by the requirements of the program.
Let's step through how the MVC control flow happens in practice.
So the first thing is that a user clicks on something within a view.
And what that's going to do is it's going to go and invoke
a change within the controller.
Now, some business logic within the controller
will go and reason about the change that's happened and will go and update
the model accordingly.
Once the model has been updated, it will go and fire events
to all of the views that are observing it.

And when the views receive this notify call
from the observer pattern, what it will do next
is call back into the model objects to retrieve the state that they
need to update their rendering.
And that's really the call sequence that happens within the MVC.
Now, one thing to really notice here that's somewhat unfortunate
is that all of the components know about one another.
So there is a binding between the controller and obviously the model,
because it knows how to update the state,
and between the view and the controller.
And also, the views unfortunately know about the models as well.
They need to know about the models that they want to render.
One aspect of this where there is really loose coupling,
though, is along this observer path.
It is really nice that the model doesn't need
to know anything about the views, other than the fact
that they're being observed.
The MVC pattern really does leverage other design patterns.
So we've mentioned already how the view observes
the model using the observer pattern.
But views are often also nested.
And nested views are naturally going to drive us
towards using a composite pattern.
So views often are composites.
Also, the views are often strategies within the controller.
So you can sub out different views.
Now, one thing to really notice here is that we've talked a lot about the view.
And one of the biggest downsides of MVC is
that it's often also known as the massive view controller paradigm.
That's because it's really easy to put way,
way too much functionality into your view.
And this is a problem because the views are also
the hardest part of the system to test.
So when we're thinking about MVC, we really want
to take a step back and make sure that we try to push as much functionality
as we can out of the view and into the controller, where it is easier to test
and helps us to keep our views lightweight and easier to reuse.
While MVC isn't often used within a gaming context,
just due to performance reasons, let's think
about how we might apply it to Mario.
Now, the first thing that we're going to want to do is to think about the model.
So if you think about our existing implementation for Mario,
the model is really based around the notion of a figure.
And the problem with a figure is it really
is a mix-up of the representation of the thing that's being drawn.
That's kind of the view part.
It's like, what does Mario look like?
And it's data, because the figure objects
that we have, like Mario and enemy, they're
going to know their health level.
They're going to know if they're big or small.
They're going to know how many coins they've collected.
They have a lot of information.
So the first thing that we're going to want to do
is split that figure out to have separate model and view
implementations.
So the model part of the Mario is just going
to be an object which contains its current state and its number of coins
and its health level.
The same with an enemy.
So we're going to have much more small and lightweight model objects
that we can use within the MVC pattern.
In terms of the view, we're going to have
some type of game view object, which is going to be involved
in rendering our model objects.
Now, in contrast to our existing implementation,
this game view is going to need to know how
to interpret these lightweight model objects
and turn them into figures that can actually be rendered on the screen.
Also, it's important to note how this view will be invoked.
The view is going to know that it needs to update
when it gets these notify methods through the observer
pattern from the model objects.
So when the model objects move, the view is going to update.
Another key functionality that the view is going to have is it's
going to have some type of handle input method.
So as the user presses keys or uses the mouse,
the view will go and update and interpret that input
and pass it along to the controller.
So the game controller, when it receives the input from the view--
because remember, the view is just going to send the raw input up
to the game controller.
When the controller receives that input, it's
going to go and move the model objects around appropriately.
So the controller is going to know what it means to move left or right.
And it is going to know what the map looks like as well.
So it'll make sure that you can't move through a wall.
So that will all be taken care of within the controller.
And it will go and update the model according
to how everything should move.
Also, If we had a game clock--
some sort of tick method-- it would be contained within this controller
as well.
Now, the controller wouldn't have to go and tell the view to render itself.
The way this would work is these updates would go and update the model
and cause changes that would trigger the view to be updated
through this observer path here.
Now, one thing to keep in mind here is if we
did want to add more views to our system,
like the idea of an overhead view, we would go and just
add the new view here.
And it would be updated through this notify path as well.
So while that view might not do anything with handle input--
in fact, that might not be wired up at all--
it would still go and get the updates and be
able to render itself according to the updated view of the model.
The main positive quality to MVC is it decouples the view
from the rest of the system.
And this gives us four main positives.
The first is that by splitting the view from the controller,
we've gone and relieved the critical path for our application
by splitting the people who work on the views
from those who work on the controllers.
Next, we've made it easy to add collaborative views,
because we can add multiple views that work on the same data sources.
Also, as we go and add new views to our system,
they're easy to add without changing the other parts of the system that
have already been developed.
Finally, in terms of testability, it is much easier
to test an MVC-based system, especially when you've managed to push as much
of your functionality into the controller as possible,
because the controller is designed in a way
that it should be easy to unit test, as is the model.
Whereas the part that is the hardest to test, the view,
has also all been cleaved off into its own independent component.
Now, there are also a number of drawbacks of the MVC pattern.
The first is in terms of performance.
If your model contains thousands or tens of thousands
of objects, when they go and started firing notifies,
it can be overwhelming for the views.
So you really need to think hard about how that update path is going to happen
and whether or not you need to aggregate these events once you design your model
objects.
Also, for a small application, this deconstruction
can be overly complicated.
So it can lead to complex system designs.
This really pays off once you get to a larger system.
But it's often hard to start with MVC, because it's
hard to see the benefits of this design.
Finally, it is so, so tempting to make your views large.
This massive view controller thing really is a problem.
And while it's often the expedient thing to go and add functionality
within the view, it is really problematic in terms
of all of the positive properties we've talked about for MVC already.
So you really need to be careful not to just put functionality into the view
because it's easy.
And this often adds extra work to your system,
because you need to go and move things into the controller
and update your models and respond to all these different events.
And it really is complicated.
But if you don't really adhere to the pattern,
you lose a lot of these benefits.