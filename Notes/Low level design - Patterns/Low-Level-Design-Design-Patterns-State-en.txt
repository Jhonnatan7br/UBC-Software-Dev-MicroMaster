
REID HOLMES: The strategy design pattern gave us
a way to vary the behavior of our programs in a very static way.
In contrast, the state design pattern gives us
a way to vary the behavior of programs in an incredibly dynamic way.
So the problem that the state design pattern is trying to solve
is that we often want to vary the behavior of our program
based on the internal state within our program.
And this is incredibly important, especially
in an object-oriented context, where the state of our objects
will change over time.
The solution to this provided by the state pattern
is to encapsulate states explicitly within state objects
and allow those objects to manage the transitions between different states.
This removes these responsibilities from the client objects,
which is great because it makes it easier
for us to add new states to our system without modifying
all of the different clients that already depend
on the states which existed before.
The solution provided by the state pattern
is to explicitly capture states within state objects
and allow these objects to control the transitions between states
within a program.
This removes the responsibility of state transitions from the clients
and puts them within the states themselves.
This is great because it makes it easier for the clients
to evolve over time as we add new states to our system,
because the states themselves are in charge of those transitions.
Here we have the canonical depiction of the state design pattern.
And if you take a step back and just look at it,
it looks exactly the same as the strategy design pattern,
except for this one field right here, the reference to the context
object within the state.
Now the way that the state design pattern enables our programs
to be open for extension is that we can add new states relatively easily,
just like in the strategy pattern.
So we can go and we could add a concrete StateFour here if we wanted to.
Each of these states represent a state within our system.
And again, we'll look at a concrete example
to show you what that means in a minute.
So the context object is also similar to what we saw in strategy.
There's this field here called state which references
the current state of the program.
Now the main difference between the two patterns is how they change at runtime.
In particular, what happens to this object here, this state object?
Through the context object, a state--
say you were in StateTwo.
You'd say, this.context.setState() And change the state to be a new object.
So this state reference here will change repeatedly,
hundreds, thousands of times as the program runs.
This is an incredibly dynamic field.
What's good about this is it means that the client doesn't
need to do any work to manage the current state of the program.
We know that if we're in StateTwo and we take an action,
that object can decide whether or not we move to StateThree or StateOne.
And the way it does it is by calling context.setState().
And in this way, the state design pattern
is incredibly responsive to runtime state changes.
Let's take a look at a concrete example of how the state pattern could
be applied within the Mario game.
So if you iteratively developed your Mario project,
you might end up with a block of code that looks something like this.
How this happened is we added new features over time,
and each time we encountered a new behavior,
we just added to this block which handles the states within our system.
So this says, when Mario is small and he is hit, he's going to die.
But if he's big and he hits a star, then he's going to become invincible.
But there are lots of states that can happen here,
and this is why this becomes really complicated.
What happens if he's big and he's hit, or if he's small and he gets a star,
or he is already invincible and he gets another star, or he's big
and he hits another mushroom?
There are a lot of different options.
And this block of code can become very complicated.
This is especially problematic if the code
gets duplicated throughout the system.
So you might have behaviors that become inconsistent over time.
So what the state pattern does is it gives us
a mechanism to make the states more independent within the system
and more self-contained.
When using the state pattern, it's often helpful to start with a state diagram,
so you can capture the states that your system is
going to transition through at runtime.
So when you start the Mario game, Mario always starts small.
And if he gets hit while he's small, he's going to die.
And so the terminal state in the state machine is for Mario to be dead.
Now if Mario, while you're playing the game, hits a mushroom,
he's going to transition from being small to being large.

And if Mario is hit while he's large, he'll
transition from being large to being small.

Additionally, if Mario gets a mushroom while he's large,
he's just going to stay large.

Now where this diagram gets a bit more complicated
is once we start to consider the invincible states.
So let's take a look at those now.
To simplify this discussion, what we've gone and done
is added a superstate around small or large,
because of the state of invincibility doesn't depend on Mario's size at all.
So if Mario picks up a star while he's either small or large,
he's going to become invincible.

And how does Mario get out of this invincible state?
Well, it turns out that there's an internal timeout on a star.
You're only invincible for a specific period of time.
And when that period expires, you'll go back to whatever state
you were in before.

Now there's one other transition in here that's also important.
If Mario is hit while he's invincible, he just stays invincible.
Nothing actually ends up happening.

So in this way, this state machine captures
how Mario transitions between small and large and invincibility.
And this lets us think about what the states within our system are
and how we need to wire them up within the state design pattern.
When you start looking at the classes, the state diagram on its surface
seems quite complicated.
There's a lot here, and all this is really
doing is trying to replicate and improve the evolvability of that block of code
that we were showing you before.
At the same time, though, there's a lot of flexibility here.
So let's really dig into how this pattern actually works.
So the first thing that you'll notice is that there's this MarioState interface,
which keeps track of a context.
And in our case, the context for this design is the Mario class itself.
So it has this field that's a Mario, and then it
has the methods that can be invoked on the states.
So for the diagram that we had before, those were hit() and trigger().
hit() was when Mario got hit by an enemy,
and trigger() was the method that happened when you encountered
a mushroom or a star.
And then we have our three main states.
And these came from the state diagram again.
So we have Small, Large, and Invincible.
Now between Small and Large, they're essentially the same.
They have the same methods, and everything is common amongst them.
Invincible is a little bit different.
It has this field called lastState, because if you recall,
when you time out when you're invincible,
you need to make sure that you go back to the correct state.
So it has to keep track of where it's going back to next.
Also, since it has to keep track of where it's going back to next,
we need to pass in that last state into the constructor.
And there's also this private method.
So when the timeout happens, it makes that transition actually occur.
Now all of these pieces end up getting wired together
within the context itself through this state field.
The state field in the Mario class keeps track of what state Mario is in now.
Now the main thing to realize is at runtime, when this code is actually
executing, Mario doesn't have this big block of code
where it's saying, if small, if big, or whatever.
Mario only has one field, called state.
And what it's going to do is it's going forward
requests using delegation-- again, using composition
here to compose Mario with its state.
So it will forward requests on to the correct state object.
So in this case, if Mario is hit, what it's going to do is it's going to say
this.state.hit().
And it will go into whichever one of these is currently active.
And the hit will happen.
So we know from before if the state is currently Invisible,
this hit isn't going to do anything.
But if the state is Large and a hit is encountered, what it's going to do
is it's going to call its context.
So it'll say this state, the Large state,
will need to transition to the Small state.
So it'll say this.context.setState() with a new Small state.
So what the Large state will do is say, hey, I'm
responding to being hit while large by making Mario small.
And Mario didn't have to think about that at all.
It's fully handled within the pattern itself.
There was a lot of detail in that last walkthrough there,
so let's take a step back and really think about what's going on.
So the main two things to keep track of is
that the state that Mario is currently in-- the MarioState interface
has this field that points back to the context object.
The state knows what context it's associated with.
The other thing is that the Mario object itself has a state field,
and it has a setter for that field, in the case of setState().
So that field is expected to be changed dynamically as the program is running.
The reason we have this reference back to Mario from the state object--
so this context reference-- is only to enable us to call that setState()
method.
So the responsibility of all of these state objects is to call the setState()
method appropriately.
Now what that gives us is it makes it so that changes
that are related to a single state are all isolated within the state itself.
So every transition out of the Invincible state
is handled within the Invincible class.
Every transition out of Large is handled within Large.
And every transition out of Small is handled within Small.
Let's take a look at another example, so we
can try to understand a little bit better
about what's going on when this pattern is executing at runtime.
So imagine the game just started.
Mario is alive, and Mario always starts as Small.
And we know that from our state diagram from before.
So we have a small Mario.
So this state object within Mario here contains a Small instance.
So it's a Small object.
Now Mario is then hit by an enemy.
You just walk right into the first enemy that you see.
So what happens is Mario.hit() is going to be called from the level class
or from the game frame.
And that's going to go and trigger this hit method.
Now rather than that method figuring out what to do,
it's going to use composition through the state field
to ask its current state what should happen.
So what will happen there is this state method will access this hit() here,
which is going to invoke the hit() implementation in this Small class.
And when the Small class is hit, it knows that Mario has to die.
So it's going to go and use this context field right here to say, hey,
this.context.die().
Mario has to die.
And this is really nice, because Mario didn't
have to think about how to respond to this hit action.
It delegated it entirely to the Small object.
All right.
So let's take a look at another example where Mario is large.
So you've picked up a mushroom.
So now Mario in the Large state goes and encounters another mushroom object
within the game.
So that's going to call trigger().
And we'll go and access the Large.trigger() with a mushroom.
And what happens when Mario is large and encounters a mushroom?
Nothing.
So it's totally fine.
But let's say we continue this same part of the game,
and Mario then goes and hits an enemy.
All right, so, again, what happens is hit() is going to go and trigger
the hit() within the Large state instance.
And in that hit() method, what the game needs to do is update Mario's state
to now be small.
So again, it's going to use this context field.
It's going to say this.context.setState().
So it's going to go and change Mario's state from Large to Small.
So it's just going to go and instantiate a Small object.
Carrying on this example, Mario is currently small.
So there's a MarioState field that is set to Small.
And Mario then goes and encounters a star object within the game.
So what happens is we'll call--
this trigger() method will be forwarded on to the trigger within Small.
Now in the Small object, when trigger is encountered
with a star, what it's going to say is, hey,
I need to change to being the Invincible state.
And this is where a little bit of magic comes in,
because we know from the constructor definition for invincible
that the parameters are a little bit different.
So in this method here, it's going to say this.context.setState().
So same as before, we're going to set state.
But we need to create a new Invincible object.
And the way it's going to do that is it's going to say new Invincible() with
this.context.
So that's the Mario.
It's the same Mario.
But the lastState is going to be the Small itself.
Because when Invincible times out, it needs
to know to transition back to Small.
So it'll also pass an instance of this.
It'll pass a reference to itself into this constructor.
And then as Mario goes along invincible, you're having a great time.
When that times out, this timeout() method will then go and call
context.setState() with this lastState that was here.
So it will change Mario's state back to small.
So that reference that we passed all the way in through this constructor
and kept track of in this field.
And in this way, Mario is able to respond to these hierarchical states
as well.
The state design pattern gives us a flexible way
to manage the dynamic state transitions that happen within our system
at runtime.
By localizing state decisions within individual state classes,
we're able to reason about the states and their transitions independently.
So when we are invincible, we only need to think about what transitions
happen out of the Invincible class.
When we're large, we only need to think about what state transitions happen out
of the Large class.
And this makes it a lot easier to reason about
how we got to where we got within our system.
Going back to the SOLID design principles,
the state pattern supports Open/Closed by making
it easy to extend the system by adding new states,
while still keeping the core of the system-- that is,
the context and the clients which use the context--
oblivious of those new states.
If we added a new state to the system, we
wouldn't have to change Mario at all.
We only need to change the parts of the states that interact
with the new state that is being added.