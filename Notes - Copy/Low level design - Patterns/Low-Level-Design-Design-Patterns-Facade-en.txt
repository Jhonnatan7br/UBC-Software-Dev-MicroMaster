
REID HOLMES: Sometimes after implementing a subsystem
we realize that it is really complicated for clients to use.
The facade design pattern is a structural pattern
that tries to make it easier for clients to use a subsystem by reducing
the subsystem's apparent complexity.
The facade pattern reduces the apparent complexity of a subsystem
by really thinking about what the high level tasks are
that subsystem is trying to support.
By supporting these tasks directly within the facade interface,
the client doesn't need to go and read a bunch of different type declarations
and learning how to use those types independently.
Instead they just interact with the facade itself.
Here we have a complex subsystem consisting of five types, A, B, C, D,
E. And two clients, client 1 and client 2.
Now the developer who wrote client one, needed to know about types A, C and B.
These are the three types within the subsystem that client 1 uses,
and the developer who wrote client 2 needs
to know about types, A, C, B and E. They need
to know about four different types.
But learning how to use those types is complicated.
So what we would like to do in the facade pattern
is simplify what these developers would have
needed to know to learn how to use this subsystem correctly.
Here we've gone and added a facade to this subsystem,
so client 1 and client 2 only need to interact with the facade,
and the facade goes and forwards requests
onto the types within the subsystem that are required.
So using composition, facade is able to hide all of these internal types
from the clients, unless they actually need them.
Now like we've said before, it's really important
that the facade not block a client from doing some task
that they might have otherwise wanted to do.
And it turns out in this case, that the facade doesn't
provide a usable access to type E, and that was something
that Client 2 actually needed.
So Client 2 could still have this dependency here,
where they depend on type E directly, but use
the facade for their other tasks.
So in this way the facade pattern has gone and simplified this subsystem.
Client 1 only needs to know about this one type, the facade type,
and Client 2 does almost everything with the facade,
but still accesses type E for this small piece of specialized functionality they
wanted access to.
One thing to keep in mind with the facade pattern,
is it really does provide this simplified view of a subsystem,
but that simplified view can also make it easier for us
to reuse this code in the future.
Right, so if we want to reuse the client without using the whole subsystem,
we want to reduce our dependency on these internal types.
And the way that we do this is using dependency inversion
from the solid design principles.
So the methods within the facade are going to take interfaces as parameters
and make sure that it always returns interface types in their returns.
In this way if we wanted to reuse the client 1 year all we would need to do
is reuse the interface declaration of facade,
and reuse the interface declarations of any methods within that facade
that we need to actually interact with.
So we wouldn't need to reuse the concrete implementations of A,
or the concrete implementations of C. We would only
need to reuse the interfaces that A and C implement.
This makes it a lot easier to reuse the code in the future,
because again, we can provide our own implementations
for those interfaces that are appropriate for our new context.
In summary the facade design pattern is a structural pattern
which simplifies access to subsystems.
By using composition the facade goes and hides
the implementations of these different types
from clients, unless they explicitly need
to use them to perform specific tasks.
In terms of low level design principles, the facade pattern
really does encourage weak coupling between clients and the types
within the subsystems.
And even when the client still needs to use types within the subsystem,
they end up using fewer types.
So again the coupling between the clients and the types
still are reduced if the facade is used at all.
Now, if you think about this in terms of the solid design principle,
the facade does seem to violate the single responsibility principle.
This is because the facade provides access
to a great many tasks within the subsystem.
They're the most important tasks, but they're probably buried,
because by definition their implementations
are spread across different types.
And since we've spread them across different types within the subsystem,
they're probably conceptually spread apart from one another as well.
This kind of trade off is extremely common in practice,
so the facade does violate the single responsibility principle,
but at the same time really makes it so that clients are much easier to reuse,
and clients of the new clients for the subsystem
are easier to write in the first place.
So when you're thinking about your designs,
is it really important to take the time to objectively think
about the kinds of support you might want to have in the future.
And this will drive you towards making different types of design decisions,
even if they seem to violate the solid principle at a high level.