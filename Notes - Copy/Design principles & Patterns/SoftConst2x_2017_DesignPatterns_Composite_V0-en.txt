
ELISA BANIASSAD: The composite pattern provides a really principled solution
for an object oriented version of a hierarchy.
The classic example is folders and files.
So you have folders that contain files.
Those folders can also contain other folders,
which also contain folders and files, et cetera, et cetera.
And ultimately, we want to be able to view them and treat them
in a tree structure.
Imagine we're trying to implement an online course.
We have topics and we have lectures.
Topics can have subtopics.
Like within the design patterns topic we might have multiple subtopics
like observer and composite.
Topics can also store individual lectures, like sets of notes.
One thing that we might want to do, in addition to tons of other things,
is see a listing like a site map of all of the topics,
subtopics, and lectures in the course.
We know topics hold both subtopics and lectures,
so we would want to include both of those as fields.
Then, we would need behavior to actually add topics
and lectures to those two lists.
So we make two add methods that insert elements into those.
And finally, we'd want to add the display behavior
to facilitate our site map display.
So we have these two loops, one displaying lectures
and one displaying topics and they're really similar.
Every time we call display with one more indent level
so we'll get a nice hierarchical structure in our view.
But let's look critically at this with regard
to cohesion and the single responsibility principle.
Now, inside of our topic we really have two different responsibilities.
One is maintaining the topic itself.
But the other is maintaining the lectures.
Of course, in the lecture Java class it has its own display method.
That's true.
But in topic, we still have to worry about displaying all of the lectures.
So it kind of feels like there are two things going on right in here.
Also, there's just a ton of duplication.
Here we have a loop that says lecture.display
and here we have a loop that says topic.display but both of these things
are exactly the same line of code.
But because each of these two things are not the same type
we can't collapse this duplication at all,
without making things really complicated.
So things are already kind of bad and now imagine if we added videos.
We would make a new Java class called video.
And it would be really similar to lecture.
And then we'd have to do all the same things.
We'd need a list of videos inside of topic,
we need to be able to add a video to a topic,
we need to add another loop for displaying all the videos in a topic.
And this is all starting to feel really repetitive.
And as we do it, we're likely to make errors that we might not catch.
So if we had to add something else, like practice problems for example,
we'd have to do all of this again.

So now we can see that this is going to get really,
really repetitive and prone to error.
So there must be a better way.
Let's run the code and see what it looks like.
And we can see that everything is displaying.
So this code is working.
It's just not really adhering to the design principles.
So let's examine what we have right now.
We have three lists that look almost identical.
We have three methods that look almost identical.
And we have three loops that look almost identical.
And there's nothing we can do about the duplication because of the way
our classes are structured right now.
So the design patterns folks also noticed this lack of cohesion
and this sort of duplication with in this one class.
This tangling of behaviors.
So they had the same response that we did.
And that was let's build an abstraction that lets us
solve a few of these problems at once.

So what they did was they came up with a higher level of abstraction
that would sit on top of these kinds of elements.
So we have a module here.
That's what we're calling it in the composite pattern it's
called something else.
But for our example, what we might do is introduce this higher level module,
like a course module and then each of these elements, each of these classes,
would extend that module.
So now a topic is a module, a lecture is a module, a video is a module.
And into module, we would actually only put one behavior.
And that's the display behavior.

Now, topic lecture and video would each need their own displays
because they would each do display specially.
But we would know that if something is a module,
if it's declared to be a module, then it can definitely do display.
So this gives us a lot of power.
So in to here, we would put a special implementation of display.
And another one of display here.
And another one of display here.

But where things get really great is that you actually
don't need to have the add method in each of these classes.
Because you don't need to add anything to a video and you
don't need to add any submodules to a lecture.
You only need to add submodules to a topic.
So in here, we wouldn't have add lecture, add video, add topic.
We wouldn't be maintaining these three lists.
Instead, we would maintain one list and that's a list of modules.

So we would put an association here, back to here with a little star,
and we would have a method that let us add to that list field.
So that method would be add module.
And in some organizations of this, we would actually see a diamond here
to indicate that a topic is really made up of modules.
Let's make a new abstract of a class called module.
And module is just going to have an abstract display method.
And now, following the composite pattern,
we want to make lecture, video, and topic all extend module.

Now, we want to go into topic and get rid of some of this duplication.
So we comment out all of these lists and replace them
with a single list of modules.
Similarly, we can comment out these duplicated methods
and just have one called add module.
Then we can kill all of this code and replace it
with one loop, that loops over modules, generically.
Next, we can go into main and add all these topics and lectures
and things using add module instead of the three old add methods.
Wonderful.
And now we run this again and it looks mostly the same.
It's in a slightly different order, which
is fine since things were being stored individually when
they were different types of things.
And now they're being displayed in the order they were added,
which is just fine.
So we're done.
The composite pattern has helped us increase our cohesion
and eliminate a ton of duplication from our code.
So by evolving our core system, we have managed to effectively derive
the composite pattern.
So the composite pattern has three collaborators.
It has a component, which is this higher level
thing that has a declaration of an operation
but probably no implementation in here.
This can either be described or defined as an abstract class,
if you do want some default behavior, which would be very unusual.
Or an interface.
If you don't-- if you definitely don't want any implementation in here at all.

Then we have the two subtypes.
The more interesting one is the composite.
And that was our topic.
That's the thing that can have submodules, or subcomponents.
So this class needs two things definitely in it.
It needs the operation that you can call on each thing
when you're visiting each component, but it also has this add component
to maintain this list.

And finally, we have the leaf.
And in our old system, the lecture and the video were both leaves.
Neither of them contained a list of sub modules.
So those still have the operation.
So that when you visit them, then you can still call, display,
or whatever it is that you're trying to do to each element in your tree.