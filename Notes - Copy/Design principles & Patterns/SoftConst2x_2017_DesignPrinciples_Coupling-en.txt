
ELISA BANIASSAD: Coupling is kind of the, almost the inverse of cohesion.
So cohesion is all about what fits inside of one module
and how well it all goes together.
And coupling is about the relationship between modules.
So when we think about coupling, the thing we really want to understand
is if we make a change here, how much of that
change is going to be felt over here?
There are lots of ways that two modules can relate to one another.
And specifically, lots of ways in which this model will
have to change if this one changes.
So here are a couple of not so bad examples.
If module x has a field of type module y.
That's kind of OK because if module y changes,
then module x can hopefully, just use that field without actually
noticing that anything under the surface has changed.
If module x calls a method on module y, then that's kind of OK too.
If that method signature changes, then yes,
module x will have to change its call.
But the compiler will tell you that.
IntelliJ will kind of complain about things and say hey,
you need to make a change over here.
So you're not going to be running your code when you find this out.
You're going to be able to do this before you actually ship it.
A far more insidious kind of coupling is coupling
between the implementations of classes.
Meaning that a change inside of the implementation of one class,
results in you having to change the implementation of a different class.
That kind of change is probably only going
to be noticeable by you when you actually run your code.
So you're not getting any help from the compiler.
And that's a disaster because you're going
to have to meticulously test and just keep track
of all of this low level of detail.
So here's an example because it's hard to just conceive
of what that might look like.
Consider these two classes.
We've got the customer class and the day view class.
And this is maybe part of our hair salon application.
And inside of the customer, we're printing out
the record for the customer.
And we're printing dash, dash, dash, and then the name.
And inside of the day view, we're printing the day.
And then dash, dash, dash, and then the day.
And then there will probably be a list of customers, as well.
So notice that they share something.
They share this dash, dash, dash output convention.
And when you print it, it's going to look really lovely.
Because everything is going to be all nice and consistent.
But that consistency has to be maintained by keeping these two
methods totally in lockstep.
So if you change the implementation of this method,
not the signature, but the actual implementation,
than the actual implementation of this method is also going to have to change.
And that is really problematic because you're probably
going to forget a couple of these.
And every time you run it, you run it in a different sort
of set of configurations, you're going to notice.
Oh dear, I forgot one of those dash, dash, dash spots.
So this is why it's always best to have coupling very, very
cleanly between method calls.
So it's abstracting this out and making it
a method instead would help improve the coupling in this application.
We also want to take a look holistically at the coupling in our system.
We want to see if the relationships that exist between the modules
are those that we want.
So in the drawing player application we have a very strong architecture.
It kind of moves down like layers.
So we have this top layer that's our user interface,
it uses the players and the model.
And the model uses the sound.
And everything kind of slows down.
So all the coupling in our system is a downward coupling.
Except that we have one class, inside the player's package,
which is the drawing player, which has a reference back to the drawing editor.
Specifically, it remembers the width of the drawing editor.
So that means that we have coupling back up.
We have knowledge that goes the opposite direction.
Maybe that's OK because it's just a tiny little thing
but maybe we actually are really bothered by this
because we want to maintain complete separation of this higher level.
We want to be able to replace it entirely and use our entire lower
levels of the architecture with a completely different user
interface with a totally different implementation.
To facilitate that, we could probably get rid of this coupling
by simply passing that little variable down
into the drawing player when it's initialized.
That way, it would store it locally instead
of maintaining this reference backup.