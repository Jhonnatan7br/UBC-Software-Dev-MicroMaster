
Now let's look at the Liskov Substitution Principle.
Before we get into the principle itself, I'm
just going to quickly remind you what substitution means.
So remember that we can have a type, and then we can have a subtype.
And that subtype is always substitutable for its supertype.
That means that we can declare a variable to be of a certain type
and then instantiate any of its subtypes to use for the implementation.
It also means that we could declare a parameter to be able a type
and then pass in any instance of one of its subtypes.
The Liskov Substitution Principle turns on
not whether you can substitute one type for another, but whether you should.
So let's think about this arrangement of classes.
This is one of the classic examples when talking about this principle.
So we have a bird, and then we have kinds of birds.
We have an eagle, and we have an ostrich.
And this all makes sense, because in our minds, both an eagle and an ostrich
are birds.
But let's think about how we've defined a bird to be.
A bird can eat and lay eggs or whatever, and a bird can also fly.
Now, an ostrich cannot actually fly.
An eagle can, so that's awesome.
But if we have a method like makeFly, and we pass an ostrich in,
then this method becomes a little strange.
We don't know what this ostrich should actually do in this case.
It isn't actually a great subtype of bird,
because if you want a flying thing and you get an ostrich,
then you're going to be unhappy.
The Liskov Substitution Principle has a lot of different components,
and we're focusing on this one.
So what do all these things mean?
Well, a post-condition is kind of like the effects clause
that we would have used to specify our methods,
and a precondition loosely corresponds to the required clause.
So weakened and strengthened we're going to get into in a minute,
but what I'm going to tell you about now is just a quick way
to remember which should be weakened and which should be strengthened,
because I find that people have a really hard time remembering which is which.
So if we think about an operation that cannot be substituted,
then it might be a sad operation.
So it might have a frown.
If we think about what a frown looks like, it's wider at the bottom
than it is at the top.
If we say that the top are the preconditions,
the nose can be narrower.
So here, we can have strengthened, or tightened preconditions.
At the bottom, we can have looser, or weaker post-conditions.

The opposite is also true.
So if we have a happy face, that means that we have a substitutable method.
A happy face has a smile, which is wider or looser at the top,
so we have weaker preconditions.
And it's tighter or narrower at the bottom, which
means we have stronger post-conditions.
And an operation with this arrangement is substitutable for its supertype's
operation.
So now let's really unpack what weakened and strengthened means--
like what it looks like when you're dealing
with a particular class-subclass arrangement.
So here we have a doctor, and a doctor has a bookAppt method.
And then we have a subtype, specialist, which overrides that bookAppt method.
And the doctor's bookAppt method accepts times in a range of 9:00 to 5:00.
So if you want to book an appointment at 9:00 AM, you can, if you have a doctor.
However, the specialist only allows bookings from 10:00 until 2:00.
And that means that if you were to call Doctor.book,
and this doctor had been declared to be a specialist, that this would
be unhappy, because the preconditions of this implementation of the method
are stronger, or narrower, than the preconditions of this one.
This one has a requires clause that the parameter be between 9:00 and 5:00,
and this one has a narrower requires clause,
that the hours be between 10:00 and 2:00.
So this book appointment is not substitutable for this book
appointment, which means that the whole class becomes unhappy.
The specialist is not substitutable for a doctor.
So once you've realized that you have an un-substitutable subclass,
what do you do?
Well, there are lots of ways that you can resolve the situation.
But there are a couple of pretty simple approaches.
So in the case of your bird, eagle, and ostrich, what you might want to do
is make a Flyer or Flyable interface, and put
all of the behavior related to flying inside of that interface.
And so then, you would make the eagle and any bird
that can fly implement that interface.
That way the ostrich would have no expectation
of having to fly at all, which is great.
In the case of the doctor and the specialist what you might want to do
is rethink the relationship between the doctor and the specialist.
The specialist was really subclassing the doctor just
to be able to get all of its cool operations.
But another way that you can get something's operations
is to use one of them, so to have one as a field.
So instead, what we might want to do is change
that extends relationship into a uses relationship,
or build an association from the specialist to the doctor.
So we would build the specialist class such that it had a doctor field.
Then it could call all of its methods and effectively wrap
all of the methods of the doctor for its own purposes.
Then there would be no expectation that it had to live up to all of the things
that a doctor can provide, including the range of appointments
The Liskov Substitution Principle is a really great way
to know whether you have a valid substitutable subtype.
However, there is an even simpler collection
of ways to just sort of intuit whether your subtype is actually
substitutable for the supertype.
So here are just three simple, simple ways
to think about the subtype-supertype relationships.
The first one is the substitution test.
Just try substituting it.
So you might declare something to be of the supertype,
and then try substituting the subtype.
So you might say, student s equals new student registration system.
That makes no sense.
The student registration doesn't make a very good substitution for a student.
However, if you were to think, Bird b equals new Eagle(),
this would feel pretty natural.
And eagle is substitutable for a bird, especially if it can fly.
The concatenation test is another nice way
to intuit whether you have a proper subtype.
So if we were to say "eagle bird," that would feel very natural.
But if we were to say "student registration system student,"
that would make no sense at all.
So by concatenating the words together, you
can sort of tell whether you have the right subtype.
But the mother of all of these intuition-based reasonings
is the Is-A Test.
Is the subtype a supertype?
So if we say an eagle is a bird, this makes complete sense.
However, if we say the student registration system is a student,
this makes no sense at all.
So this tells us that no, student registration system
should not be a subtype of student.
Now why would you have made it a subtype at all?
Maybe because you wanted to use some things that were inside of student.
Just like our previous specialist-doctor example, you should make that a field
or an association, not a subtype relationship.