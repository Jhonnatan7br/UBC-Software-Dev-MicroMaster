
ELISA BANIASSAD: Now we're ready to talk about our third and final design
pattern, the iterator pattern.
All the patterns that we've looked at have increased cohesion of our designs
in some way, or introduced a better, more principled approach
to a certain organization.
Iterator does that too.
Specifically, it lets you abstract out the logic related to iteration.
So we have a toy store, and it has an inventory.
Inventory is a special collection that we're implementing ourselves,
because an inventory does more than just the generic Java collection,
because it wants to log behavior and do other inventory management things.
So we can't just declare inventory to be an array list,
instead it's a whole class that just keeps its internal data
as maybe an array list or some other kind
of internal representation of the toys of which it's keeping track.
However, we want to be able to iterate over this inventory
like we could iterate over a normal collection.
We want to say for all the toys in the inventory, try and sell them,
but that doesn't work.
And notice that we're getting this error for each
is not applicable to model dot inventory.
So what we would have to do instead is we'd
have to write a much more complicated loop to get the behavior that we want.
We would have to write this loop that gets the size of the inventory,
and then cycles through to get each toy out of the inventory.
But here's the problem.
This loop actually knows a lot about what
the inventory looks like internally.
It knows that we're indexing into our inventory,
and that means that our inventory will always
have to index our toys by some kind of number.
If we were to do something completely reasonable like changing
our inventories to store a set instead, like this,
then suddenly there is no underlying index in our inventory
and this code will break.
And, of course, we could fix it on the client side,
but it's going to get a lot more complicated.
And now you have to know that all of this is a violation of coupling.
We have two classes that are highly, highly coupled to one another.
And this is also a violation of cohesion because our toy store now
has a little bit of internal knowledge about the inventory.
It's kind of an inventory manager as well as a toy store,
so that's not great either.
So we need to fix this.
Enter the iterator pattern.
An iterator is a very cohesive class that
knows exactly how to traverse a specific collection.
So each collection has its own version of an iterator.
An iterator has kind of three components.
First, it has a cursor that keeps track of where you are in iterating
over a particular collection.
Then, it has a has next method, which returns a Boolean value.
It returns true if there are more elements in the collection to traverse.
And finally, it has the get next method.
The next method has all of the logic for figuring out
which the next element of the collection should be,
and it returns that element back to the caller.
Every collection in the Java libraries has its own dedicated iterator.
So for instance, ArrayList has its own ArrayIntListIterator.
To make that relationship work, ArrayList
doesn't keep a field of this iterator.
Instead, it has this iterator method that it's
forced to implement because ArrayList implements collection
which extends this iterable interface.
This iterator method just returns the dedicated iterator
to whoever is trying to iterate over the array List.
Inside the ArrayIntListIterator, we see all these great methods
that we were referring to before.
So this ArrayIntListIterator would then have the has next
and get next, so that it will know how to walk this specific kind of thing.
So let's come back to our fantasy loop and figure out
why we can't iterate over our collection using this lovely arrangement.
Now, what Java does when it sees a loop like this,
is it actually generates a whole bunch of code.
This is kind of what's called syntactic sugar for something
a lot more complicated, and here's the code that it generates.
It declares a new iterator over type toy, so it gets its type from here
and fills that in for the thing that it's going to be iterating over,
for those elements that it's going to be returning.
It gives the iterator some name, and then it
calls this iterator method, the one that sits right here inside of iterable.
It says inventory dot iterator.
Well, we can see our first problem right away,
our inventory class, which might sit here,
does not currently extend collection.
We don't really want it to extend collection.
But in not extending collection, it also doesn't implement iterable.
So the inventory class that we have does not yet have this iterator method.
So once this line of code has been generated,
then Java will generate an additional loop
that it can run using this little iterator.
So it will generate a while loop, which will
keep running until there are no more elements
being returned by the iterator.
So here we see the iterator is TI, we see
while TI dot has next, while there are more elements in the collection,
then continue.
Then it declares a new element that it gets
from this element type that comes from this spot in our fantasy loop,
and it gives it some name.
And then it says TI, toy iterator dot get next.
And then that is what the rest of the loop will then be able to operate on.
So our job now is to implement the iterator method for inventory,
and make it implement iterable so that this loop will
know that it can generate this code.
So let's make our inventory implement iterable.
We'll erase this code that's violating the design principles,
and we'll try to get this original code to work.
So we'll go into our inventory, and say IT implements iterable.
And remember, that we have to say what it's going to be iterating over
as a parameter to this type.
Since our loop is asking for a toy, that is what we return here.
So we say implements iterable over toy.
And, of course, it's not happy because we need to implement these methods.
But actually, it's just one method, this iterator method.
We don't need to implement any of these optional methods.
They're beyond the reach of this class.
So here, we have to decide which iterator to return.
So remember, that we need an iterator that's
a dedicated class that knows exactly how to iterate over our collection.
Now, we could see our collection as the inventory as a whole with a log
and everything, but actually the inventory part
is just this list of toys.
So if we want to iterator that knows how to iterate over an array list,
we just have to use the ArrayIntListIterator.
We're just going to respond with the iterator that's already dedicated
to our toys list, because remember, anytime you instantiate an array list,
you're also getting an iterator for free.
So let's just give back that one, toys dot iterator,
and now, when the foreach loop calls inventory dot iterator,
it will get back the iterator that is dedicated
to this very instance of our collection of toys.
So now, we should be able to run this code, and see it doing the iteration.
It says, may I interest you in some lovely blocks and some lovely wool?