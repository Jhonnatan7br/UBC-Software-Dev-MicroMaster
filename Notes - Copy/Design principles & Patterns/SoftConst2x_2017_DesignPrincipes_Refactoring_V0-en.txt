
ELISA BANIASSAD: So we've talked about all these principles,
but how do we achieve these principles?
Do we build our code perfectly from the ground up?
No, we do not.
You can't possibly do that.
We do our best, but no one can imagine how things will change as time goes on.
So instead of trying to plan for everything,
we do something called refactoring, Which means restructuring our code
to make it more readable.
When we refactor, we don't change any of the behavior of our code,
we only make structural changes.
So before we start refactoring, we want to have a fully working code
base with exhaustive passing tests so that we
can be absolutely certain we haven't broken anything
by making our structural changes.
Now in this case, I don't actually have completely exhaustive tests,
but we have a decent set of them.
You can go in and add more tests on your own.
Let's run this hair salon test and make sure all the tests pass.
And great, they do.
So we noticed that hair salon had lost cohesion.
It basically has these two different concepts--
the treatment specialists and the booking behavior.
And really, they should be separated.
We noted before that what we really wanted
is something like a bookings manager and a specialist suggester.
So what we can do is actually rip out those two classes
from our hair salon class.
Because if we look at the structure, there
are a lot of methods that deal only with booking,
so we could straightforwardly put in a bookings manager.
And there are other methods that totally deal with treatment specialists
that we could relocate to a specialist adjuster.
Let's tackle one of these movements of code.
Let's make a new class called specialists adjuster
and take all of those relevant methods out of hair salon.
So we're going to do this in a really step-by-step way,
because we want our tests to keep passing.
So we know that we're going to need this field inside our specialists adjuster.
Because our specialists adjuster basically
has to steal all the functionality and all the data
inside of hair salon that has anything to do with suggesting specialists.
So we want this field, but rather than actually removing it
right away from hair salon, we're going to copy it for now.
Because as I said, we don't want to totally break our hair salon,
because we want our test to keep passing.
Then we want to copy all of the methods that
have to do with suggesting a treatment, which is these three methods,
and we copy all of those and paste them into our specialists suggester as well.
So this is the behavior from our hair salon
that has to do with suggesting specialists.
But there's still some code in our constructor
that has to do with the specialist adjuster.
All of this, all of this setup.
So we want to move the setup over as well
into the constructor for the specialists adjuster.
Fantastic.
Now we should be able to comment all of this out,
and instead, just call specialists adjuster
equals new specialist adjuster.
However, now we have broken our tests, because we've
got into kind of an intermediate state.
And the reason for that is that we're still using
suggest consultant inside of our hair salon.
We still want the hair salon to be able to suggest consultants,
and we don't actually want to have to tell main that it now
has to talk to a different person.
So what we want to do instead is reroute the call from inside of hair salon
down to the specialist adjuster.
So as far as main is concerned and as far as the tests are concerned,
nothing has changed.
So actually, before I do that, we want the specialists adjuster
to be a field inside of the hair salon.
So let's go put that in.
Now, to reroute this suggest consultant method, all we have to do
is return the results of our new specialist adjuster's
version of suggest consultant.
And we reroute the parameter through so that now, instead of the hair
salon using its own local behavior, it will call over
to the version that lives inside a specialist adjuster.
And now, if we run all of our tests, they should pass.
Yay, and they do!
And we can just clean up our code delete all the duplicate things
that we don't need and run our tests one final time.
Fantastic, success.
Now the next step would be to do the same thing with all the code that
relates to bookings.
It's an extremely similar movement process
to what we have just done with the specialists adjuster,
except in this case, there are just a lot more methods to reroute,
but you should try that on your own for practice.
Great, so that was refactoring to improve cohesion.
Another reason we might want to refactor is readability and reduction
of duplication.
So the next thing we want to look at is making a new booking
and canceling the booking.
We can actually see a lot of duplication between these two methods.
For example, this first conditional is exactly
the same code in both of the methods.
So what we can do is extract this code and make it its own little method.
So we select it and click refactor and then extract method.
And we can call it something like check booking time validity.
And it's suggesting parameters, which is awesome
because those are the two parameters that we would need to pull in.
And then it's telling us that it's detected that we have a duplicate,
and would we like to replace that duplicated code
with a call to this new method?
And yes, we definitely want to say yes to that.
So now we've reduced the size and increased
the readability of these two methods.
And we could keep going with reducing this duplication.
There's still a lot of similarities between these two methods,
and you can work on that on your own as well.
There's one more point I want to make about refactoring, and for that,
I'm going to go into the simple drawing player program,
into the drawing player class, and look specifically at select in place shapes.
That method has these two loops.
It's not exactly easy to understand what's going on in these loops.
It seems kind of obvious, but let's really break it down.
First, let's run it and remind ourselves what's going on.
When we play a drawing, it selects and plays
each shape that's in the current column.
So if we look inside this method, we can see
that it's looking at a particular column,
and it gets all the shapes that are in that column
with this get shapes at column col. And then
it loops to compare the shapes that are in the current column with the shapes
that are in the last column played.
And if any of the ones in the last column are not in this current column,
it unselects those last shapes and stops playing those.
Then there's a second loop.
For all the shapes that are in the current column
but not in the last column, it starts playing those shapes.
So each of these loops is doing something really different
from the other.
We can refactor this so that we don't have
to think so hard about what's going on in each of these.
We can basically collapse these loops into methods
so that we can see their names more easily.
So we can select this one loop and say refactor extract method,
and we can call it something descriptive,
like, stop playing completed shapes.
And then we can select the next one, extract that, and call it,
start playing new shapes.
And now we can reason really easily about what's going on in this method.
We can see that we stop playing the old shapes
and start playing the new shapes.
And we can easily infer that ones that are neither old nor new
will simply continue playing.
So this extracting and renaming has made our code a lot easier
to read and understand.
And this is actually something you can just
do when you're looking at a new codebase,
even, and trying to understand it.
You can just start grabbing stuff and renaming it for your own understanding,
making little helper methods along the way
to keep track of what you understand the code to do.