
GREGOR KICZALES: Now we're going to design functions
operating on arbitrary arity trees.
And what we're going to see is that even though mutual reference in types
is the most complicated data we've seen so far,
the function design is pretty straightforward.
It falls out from what we already know.
Now that we've got complete data definitions
for mutually recursive types, the data that's
going to represent the file system structure for us,
now we can start designing functions.
And the thing that's going to be pretty cool here
is designing these functions is actually going
to go very smoothly and easily because of all the method we've learned so far.
Here we go.
I'm in FS-V1.
And in this version of the file, this is just
a file we had last time, except that I went ahead and added
a little picture of this directory structure,
because that's going to make it easier to design functions.
If I had just been working by myself, I would have scrawled that out
on a napkin or something.
But I popped it in there for you.
And also, there's four function problems.
I'm not going to do all of them.
In this video, I'll do just the first one.
Then I'll do another one.
And then the other ones, you'll do on your own.
So here we go.
We're going to design a function that consumes element and produces
the sum of all the file data in the tree.
So, for example, in this tree, because the data
is always the number for a file, if we sum this entire tree,
well, that data is zero because it has subs.
That data is zero.
That data is one.
That data is two.
That data is three.
So 1, plus 2, plus 3, is 6.
That's the function we're trying to write.
So let's go ahead and follow the method and do it.
Now, the key thing is when we design functions
that operate on mutually recursive types, when
the data has mutual recursion it, we design multiple functions at once.
So here, I know there's two types that involve mutual recursion.
I'm going to do two functions right away.
So I'm going to write element to-- let's see, I'm adding up the data.
And the data is always an integer.
So this is going to be a sum of integers.
So that's element to integer, and also list of element-- because, remember,
I'm going to do both types-- to, well I don't know what this is going to be.
It might be integer, because that's what element produces.
But it might be something else sometimes.
Oftentimes, it's the same-- both mutually recursive functions produce
the same type.
But not always, so that's why I put those question marks there,
to remind me to come back and check that.
Then I'm going to say produce the sum of all the data in element and its subs.
I'm writing the purpose for the first function.
I'm writing the purpose for the function that consumes element,
because that's what I was asked to do.
Now I'm going to do two stubs.
And I'm going to call this function sum data.
Except there's not going to be one function.
There's going to two.
There's going to be the one that consumes element,
and the one that consumes list of element.
So the naming convention I'm going to use is like this.
I'm going to say sum data--element.
That's the one that operates on element.
The stub for that is zero.
And sum data--listofelement consumes list of element.
And the stub for that is probably zero.
We'll come back to that.
Now let's do so check expects-- check expect sum data--element.

Now, there's recursion involved.
So we should start with a base case example.
And when you've got mutual reference, it's
not clear quite what is the base case example.
There tends to be more than one.
Well, one example is sum data--element of F1.
That's just-- you know what I'm going to do?
I'm going to go up here to get this figure,
and bring it down here temporarily.
I'll just bring a copy of it right here so we can refer to it as we work.
And then we'll just delete it later when we're done.
Sum data--element of F1, F1 is a file for which the data is F1.
So that produces one.
That seems like, at least, a close to base case example,
because F1 has no subs.
So there's no recursion there.

Another base case example might be one that we don't quite have in here.
But some data--listofelement of empty.
What's the sum of all the data in an empty list of elements?
That's zero.
Now let's try to do the next simplest example I can think of, which is sum
data--elementofD5.

That's pretty simple, because D5 only has one sub.
Well, the sum of all the data in D5-- remember, things that have subs
don't have data.
So the actual value there is zero.
So that's just three.

And let's do sum data of D4.

Well, that's also three, because 1 plus 2 is 3.
That's plus 1 and 2.
And then let's do the top one too.
Sum data of D6 is-- what is it?
Well, it's 1, plus 2, plus 3.
And now it's really starting to look like sum data LOE
has got to produce an integer, because there's
sort of this meaningful notion of, what's
the sum of all the data in an empty list of elements?
So this is really starting to look like it's going to be integer,
but let's keep going.
OK, signature, purpose, stub, examples-- let's go get the templates.
Here's the templates.
I had also commented them out so that they wouldn't get highlighted
in black when we run the program.

There they are.
Now we'll comment out the stubs.

We'll uncomment the templates.
And when you've got mutual recursion, you really
need to be careful about the renaming of the templates.
So fund for element is going to be called sum data--element.
And there's a mutually recursive call down here that I
need to be sure to rename as well.

And fun for LOE is going to be called sum data--LOE.
And there it is.
And there's its recursive, it's natural recursion.
But here's the natural mutual recursion.
So you need to be sure to name the mutual recursions, as well
as the function definitions and the self recursions.
OK, let's see.
I want to sum the data in an element.
And the interpretation-- remember, the interpretation is that if data is zero,
then subs is considered to be a list of sub elements.
And if data is not zero, then subs is ignored.
So to know how to interpret a given element, we need to look at data first.
We need to know, is data zero?

Let's start by doing that.
It doesn't look like name has anything to do in this function.
So I'll just get rid of it.
And I'll start with if zero is the data zero-- now, if the data is zero,
it means I'm supposed to go look in the subs to see how much data is there.
So I'll leave the natural mutual recursion to do its work.
If the data is not zero, then this element is a file.
It has data.
So we're going to produce the size of this data.
Now let's look at sum data LOE.
Well, the sum of an empty list of elements,
intuition plus this example here, tells me is zero.
And, otherwise, now when you've got mutual recursion,
you've got to in a big way trust the natural recursions.
You've got to trust the natural self recursion.
You've got to trust the natural mutual recursion.
If I've got a list of element, and I have the first element in my hand,
and the rest of the elements in my hand, what's the sum of all the data in them?
Well, it's the sum of the data in the first, plus the data in the rest.
This just becomes a plus, because I'm trusting
that this thing is going to do what it said it would do,
and this thing is going to do what it said it would do.
And now that's really clear here now that I have this plus,
and also I'm returning some data LOE here.
This really is integer.
We're counting on the list of element function
to produce the same type of result as the element function.
As I said, when you have mutually recursive functions,
it's usually the case that all the functions
produce the same type of data.
But there's some exceptions to that rule.
So there we go.
We filled in all the dots.
What happens?
So let me save it, and try running it.
All five tests passed.

Now, you may have a feeling there like you had the first time we
wrote a recursive function.
Why did that work?

And the reason it worked is we have these well-formed self-referential type
comments.
It was always a base case.
And that means we got templates derived from that that supported
natural mutual recursions in the right place,
and that have a base case right here.
We formed our examples carefully and systematically.
We coded to them.
And we get a mutual recursion that has the right structure,
and that always terminates in a base case.
So, again, what you're seeing here is that the way the method
works by being data driven, in terms of getting well-formed, self and mutually
referential type comments, to the templates,
coding those to complete the functions, trusting the natural recursions, that
makes functions like this quite easy to design.
What I'd like you to do now is do this next problem
where you design a function that consumes element and produces
a list of the names of all the elements in the tree.

So that was pretty straightforward.
The key point, really, is that when you design
functions operating on mutually referential types,
you don't design a single function.
You design one for each type.
And so it pays to group the signatures together
to maybe write a single purpose, to group the examples,
and then group the functions.
That makes it easier to work on them.
Another issue has to do with the examples.
These are mutually recursive functions.
So you want the base case first.
But sometimes it's a bit more natural to put
a case that's one away from the base case first, as it was in this case.
It's worth noting here that the method we're presenting in this course
is really starting to pay off here.
In a lot of other approaches, functions that operate on trees
would be very different from functions that operate on lists.
It wouldn't be the natural extension it was here.
Really, the only thing we learned in the latter part of this week
was mutual reference in type comments.
After that, we really knew how to complete those data definitions
and write those functions.
I think that's pretty cool.