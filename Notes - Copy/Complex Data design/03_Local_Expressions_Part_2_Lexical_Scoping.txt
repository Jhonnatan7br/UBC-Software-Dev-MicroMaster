
GREGOR KICZALES: You've already seen that local
lets you have definitions that are available inside the local.
But what does that mean exactly?
Are they available outside?
What if there's a definition outside the local
and inside local that has the same name?
What if there's a local inside a local, or even one more local inside of that?
In this video, I'm going to talk about the concept of lexical scoping
and show how scope contours will let you answer any such question about local.
In this video I'm going to talk more precisely
about what it means to say that local sets up
some definitions inside the local expression.
To do that, I'm going to introduce an important concept in programming
called lexical scoping.
Let me set up a little problem here for us to think about.
Let me get rid of that local expression.
And I'll say define who is incendio.

Now, the question is, if I run this program, what am I going to get?
Am I going to get accio portkey or incendio portkey?
I'll put a space there.
That's not key to the problem.
Which of the two am I going to get?
Well, we're going to get accio portkey, which is the one I want, of course.
But the question is why?
And in order to talk about I'm going to introduce this concept
of lexical scoping and scope contours.
So the first thing to understand is, that in a program
there's a thing called the top-level scope-- the global scope,
the scope of the whole program.
So the way to think about that, is that there's a box
kind of around this whole program.
And every definition in that box is recorded in the box.
So in this global or top-level scope, we have recorded the fact
that there's a definition for p.
So there's a little notation here that says, hey, there's a p in this box.
And whenever we encounter a local, we make another box just around the local.
And every definition that's in the local gets set up in that box.
So whereas the top-level scope-- the top-level box-- just has who,
this inner scope-- this inner box-- has p and fetch.
So that's the first half of lexical scoping.
The second half is, what do we do whenever we see a reference
to a constant or a function?
Well, here's what we do.
It's easy.
We start right at the reference.
And we go to the innermost enclosing box.
And we see if that innermost enclosing box
has a definition for that reference.
So starting at this p, we go to the innermost enclosing box,
which is the box of that local.
And we say, hey, is p defined here?
And the answer is, yes it is.
And then that's it.
We're done.
We know which p this is.
It's the p that we find in the innermost enclosing box that defines it.
So this thing here is the one from this box.
So it's accio.
OK.
Now, let's look at a little bit more complicated case.
I'm just going to paste it in here.

Here's a little bit more complicated case.
Well, what's this going to produce?
Before we write it, let's try to use the scope contours to figure it out.
In the global scope there's going to be two definitions, a and b.
And it's these definitions here where a is 1 and b is 2.
And way down inside this local, there's going to be one definition for b.
And in this definition b is 3.

So now let's go look at all the references.
What are they each going to be?
Well, this first a we start at the reference a.
And we go to the nearest enclosing box, which in this case is the global scope.
And we say is there an a there?
Yes, there is.
There's an a here.
And so that a would go to this a here.
We just draw a little arrow that says that, that a is that a.
That reference to a goes to this definition of a.
OK.
Now, let's find the next reference in this program.
Well, here it is here after the plus.
It's this a right here.
Well, which a is that?
We don't know.
Let's go to the nearest enclosing scope contour.
It's this inner box.
Does it define an a?
No, it doesn't.
Let's go to the next nearest enclosing box.
It's the outer box.
Does it define an a?
Yes, it does.
So this reference to a here, goes to the global definition
of a there-- or the top-level definition of a, there.

OK?
What about this b?
Well, we do the same thing.
We start at the b.
We go to the innermost box.
We say, does this box define a b?
Yes, it does.
So this b goes to the inner definition of b.

Let's go to the next reference.
Now, let's be careful.
This b here is outside of the local.
So when we go to look at the nearest enclosing box, it's the global scope.
So which b does this end up being?
It ends up being the global b.
So with these arrows on this, you kind of see
that let's see this is going to be plus 1, also 1, 3, and 2.
1, 1, 3, and 2 is, I think 7-- sure enough.
Let me suggest that you do some exercises-- I'm about to give you
some-- to do with these scope contours.
And you can kind of check your work automatically with DrRacket.
But please, please, please, please, please, please, please,
please let me encourage you to first try to solve these problems on your own
before you use this trick I'm about show you to check your work.
In DrRacket, in the intermediate student language
when you've got locals, if you click on Check Syntax
and then you hover over a reference, it will draw a line
from the corresponding definition.
If you hover over a definition, it will draw lines
to all the corresponding references.
So that b is that b.

So you can check your work this way.
It doesn't draw the boxes.
It doesn't draw the boxes.
But it does draw a line showing you which a it is.
So you can use that to check your work.
But please please please practice some of this scope conqueror stuff
without using that.
It's really important to understand the idea of lexical scoping
without using automatic tool to answer the question for you.
