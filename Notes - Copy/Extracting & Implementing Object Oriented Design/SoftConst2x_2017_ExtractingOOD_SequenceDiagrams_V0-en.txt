ELISA BANISSAD: Now we're going to look at a totally different looking diagram.
This, again, is a dynamic style of diagram, similar to the control
flow or the flow chart diagrams that we'd seen earlier,
where they follow the path of execution, as opposed to being static and derived
from just reading code, the way that the class diagrams are.
So in this case, on the drawing are depictions
of each of the objects that's present during the execution
of a particular method.
So here we have two objects in play.
Time flows down through the diagram, so we start up here,
and then gradually, calls move down through the diagram.
So we start out with one horizontal arrow,
which represents a call into the first method of this diagram, depicted
by this bar.
This bar is actually considered the body of a method,
so you can imagine that there's an open curly bracket here
and an implied closed curly bracket here.
So we call into this method, an then this method
is calling a second method that lives inside of Object2.
So if this method was called a this object
would have just called Object2.a.
And that would have invoked this.
Again, there is an implied curly bracket here and an implied closed curly
bracket here.
This method runs, the bar extends for the duration of its running
through time, and then the return happens.
Now we're back in the original method, and then we reach its curly bracket
and return from there.
Now, we're going to look at a particular piece of code
and draw a sequence diagram from that code.
So where we start is with a particular call.
We don't just start drawing a sequence diagram for the entire project,
because that would be insane.
So we start with one line of code, and see what sequence that triggers.
So here, we're starting with a.doA.
So we have an object, A, that we draw up in it's own box, like this.
Sometimes we would also note somewhere in the box in some sort of syntax
that a is of type A, just to give more information,
because sometimes these names don't tell the whole story.
Then we see that we're calling method doA.
So we want to have that fly in from somewhere.
We don't care.
This isn't part of the diagram.
So we just have this fly in somewhere from the left,
and we write the name doA on it.
And it has a parameter, b, so we put that here as well.
Now, we have no idea when we're starting to read this code how
long this method is going to run for.
So I usually like to give myself as much length as possible.
And fill that in.
And remember, this is implied open bracket and implied closed
curly bracket and this is the duration of our method.
So we have doA, and we're passing in b.
And that brings us to this line of code.
So now we've made a call here.
Then we go through this line of code, and we see b.doB.
So we have a second object in play, b.
So we draw its box up here, and we can put its type up in the edge as well,
or wherever we want to place it so that it's depicted.
And then we depict the call from that is made right here, this doB call,
and it takes no parameters.
Then we look down here to see how long the method is
and how long the box is that we'll need.
And in fact, there are no calls made from inside of here.
So we just draw a tiny little box and fill that in.
And then we get to the closed curly bracket, so the method returns back.
Then we get to the closed curly bracket here, because nothing else happened,
and we return back again.
Now let's make a sequence diagram extract it from a real system.
So let's look at our instructor and student system for courses.
And in here, we have this registerStudent method.
And the context of this method doesn't really matter too much.
We don't care, really, where it's being called from, because we just
want to make our sequence diagram right from this method call,
starting right inside this method.
So what we're going to do is run this system using the debugger
so that we can step through, because actually, the pathway that the sequence
diagram takes is the same pathway that the debugger will take.
So we can just build it up using the debugger.
So we've started our debugger, and immediately, we
can see the three objects that should have life lines in our diagram.
We see the registration system, the online student, and the course.
And we can name those, so that we know which ones they are.
Just for now, we're even going to annotate them
with their little object IDs.
Normally you would not do this, but just for clarity in this video,
we're going to do that.
So we'd see a line representing a call to register a student come in
from the side.
Let's try the method bar right on there for the whole length of the diagram.
Now, we step into addStudent and see what it does.
We can see that there is actually an additional collaborator now
for our sequence diagram, this students list.
Let's add the students object to our sequence diagram
and give it a lifeline.
So the first thing to happen here is the call to students.Add.
And that's adding right into the list object,
so we make a call to the list object, and we label that with the method name
Add.
We pass in s, the student object, making sure that in our diagram,
its name matches the name of the online student
object at the top of the lifeline.
This way, we can see in our diagram that they're referring to the same object--
that student, online student 446 4:6
So we draw a line to the method bar for the Add call,
and then the Add method returns.
And then the addStudent method returns.
So each of those method bars are cut off right after they return.
Now, we've returned all the way back to our original registerStudent method,
and we're sitting now at a call to student.addCourse.
So we draw on the call to student.addCourse, and label it
with that method name, addCourse.
And now, if we step in to addCourse, we will be inside the student class,
obviously.
But we'll also see yet another collaborator, this courses list,
because a student has a list of courses.
So we draw on the call to courses.Add, and we
draw the method bar for courses.Add, and then courses.Add returns,
so we draw the return arrow.
And then, student.addCourse returns, and now we're back in registerStudent.
And actually we're at the end of our method.
And we've completed our whole sequence diagram.
So that shows you how to draw calls between objects.
But how do you draw a call when it's back to the same object?
Well, I've added a little line of code here inside of doB, which is doB2.
These are very inventive method names.
And to depict this call, all we would do is put an additional call right back
onto the same method bar.
We add another little method bar right here to indicate this method.
And then we would put doB2 right on this arrow,
and then we would even have a tiny little return arrow that
comes back from that same method call.
So these are actually called self-calls, or calls to this.
If you're ever making a call this.something,
then this is how it should look.
Loops are a little bit more exciting to draw in sequence diagrams because
of the way that time flows.
So let's take a look at that now.
Here we have a class registration system, or RegSys, just for short.
And it has one field, students, which is the list of students.
And then it has this method called printRecords,
which loops through all of the students and prints out the record for each one.
So in drawing our sequence diagram, what we want to do is,
we first of all want to pick a starting point.
So we're going to pick this as a starting point.
We're just going to draw the sequence diagram that starts
at the beginning of printRecords.
So printRecords lives inside of RegSys, so we're going to put RegSys here,
and we're just going to know in our minds that this isn't the whole class.
It's an object of type RegSys.
And then there's this lifeline, and then we're
going to bring in, from the side, printRecords.

It doesn't take any parameters.
Now, it's time to depict our loop.
So now we have to think about the other objects that are in play in this code.
First, I'll draw your attention to the fact that we have this students list.
It is a list of students.
So let's write that one up first.
Students.
And we can remind ourselves that it's a list, and that gets its lifeline.
And the next thing that we have is an individual student, student s.
And it gets its individual lifeline.
So this is the view of one iteration of the loop.
This is all the objects that are in play in one iteration.
So the call comes in here.
Then we get our big long method, and then we go into this for loop.
Now, the first thing that actually happens in a for loop
is that this special for each portion gets the first item of the array.
So it's going to make a secret call to get next.
And here.
You don't see it happening in the code, but it's
what's happening behind the scenes.
So we would depict that first.
Then, we get back a student, s.
And we want this to match this, to indicate
that these are the same object.
Then we see the call to that particular student, which is getRec.
So we make a call all the way over, getRec, and then
we have our little method bar.
And then I'm assuming that it has a return
value, which is rec equals s.getRec.
So this would come back with a record of this student.
And then the loop ends.
Now, every time through the loop, it's going
to instantiate a new one of these students.
You're not always going to the same student each time.
Each time you go through the list, this is going to be a different object.
So sometimes what we do in this course is
we would draw an additional student that is behind this one
or next to it or something, has its own lifeline
and you would draw a second loop around, to indicate
that you're looping through multiple versions
or multiple objects of the same type.
So that's one way that you can do it.
Another way that you can do it is to draw a big box around this whole thing,
to indicate that this is a loop over students.

And this shows that all of this will continue happening
until the students list is empty.
That resembles the statement that you would be making in the loop anyway.
So this is the preferred model of this diagram in industry,
but for this course, we really like to draw these different objects, just
to indicate that these are different objects flying
into the scope of the diagram.
All right.
So here's a cleaned-up version of that diagram.
The pink area indicates the bounds of the loop and all of the calls
that are made inside it.
Now, interestingly, if statements look almost exactly the same.
So if this had been an if statement instead,
instead of saying loop students, we would have put the condition
into this little section instead.
So now you know how to draw both loops and conditionals
inside of sequence diagrams.