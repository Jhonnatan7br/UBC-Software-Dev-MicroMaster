
ELISA BANIASSAD: So now we're going to do two things.
One, I'm going to tell you about a really useful data structure
that you'll probably have to use a lot throughout the rest of this course.
And that's a map.
And then I'm going to tell you about a nicer way to do object comparison.
A map in Java is kind of like two arrays that sit side by side.
In some languages, these are called associative arrays,
or dictionaries, or even look up tables.
So one of the arrays holds all of the keys,
and the other array holds all the values.
So you have all these key value pairs.
For instance, you could have the keys be names or something.
So you might have a name like Elisa as the key,
and the value might be another string, like my favorite food, so sushi.
To declare a map, you would write this incredibly long line of text.
So you write the type map, and then the type of the key, which in our case,
is a string--
I should put quotes around these--
and the value, which is also a string.
These can be anything, actually.
And then you give it a name, and then you say new.
And the actually instantiated thing is a hash map.
So if we wanted to put a new element in here, we could say food map dot put.
And then we would give it our key and the value
that we want to put into the array.
So in this case, we could say Erika.
And Erika likes coffee.

And after that line of code executed, then Erika would sit here,
and she would get a cup of coffee.

You can also then get things back from the array.
So you can say print out just one of these individual values
by looking up the key.
So we could say food map dot get.
And then we could say Elisa.
And this would print out sushi.
Or, we could print out all of the keys.
So we could say food map dot key set.

And that would print out Elisa and Erika.
And similarly, you could get all the values and print out those instead.
So these are really great little ways to look up
information when you need to associate one object with another value.
These maps can be even more interesting.
For example, you can have a string value as the key on one side,
and a whole array of things on the other side in the values.
So here, we have this hair salon that now has this new treatment concept.
So if you look in Main, we can see that we've
added a line of code that says suggest consultant.
We have treatments, and now we want to be
able to get specialists for our treatments.
So we're going to add a method inside of hair salon
that's called suggest consultant.
We also want to be able to add treatments to the treatment map.
And we want to be able to add specialists
related to those treatments.
So how are we going to do this?
Well, first, we have to declare our map.
So we say private map treatment.
So treatment is going to be our key, and we're
going to be able to search on treatments.
And treatments are just an object with a name and the amount of time
that they take.
And then we want an array list on the other side
to be this list of specialists.
So we'll say array list string, because it's just people's names.
And so that's our mapping.
And we call the whole thing treatment specialists.
And we initialize it as a new hash map.
So now we want to implement two different methods for our hash map.
First, we want to be able to put the treatments
into our map with no specialists.
Then we want to be able to add specialists to the treatments.
So we'll write treatment specialists dot put.
And then we want to put the treatment that's
being passed in, and then an empty list of strings,
because we don't have any specialists yet.
We're just setting it up.
And now in this method, once we have all of the treatments in our map,
we want to be able to add a specialists to the list of specialists
for a particular treatment.
So we want to get the list of specialists back from the map.
So we'll declare a local variable called names to hold it.
And then we call names dot add, and the name
of the specialists that we want to add is passed in.
Now remember, names is actually the result
of getting back the value from the map.
So this names variable is a pointer to the array list for the specialists that
lives inside the map.
So once we've added our specialist to the names list,
we don't need to call put to insert the whole names list back into the map.
You're already directly manipulating the list
of strings that's living inside the map because names
is a reference to the original in map array list.
Now let's go back to our constructor and actually call these methods.
We can say add treatment specialist with cut as the parameter for the treatment,
and we'll put Jean as the specialist of interest.
And then maybe Marie and Jerome also specialize in cutting.
And then for coloring, we have Silvie and Sandrine.
And then Mike and Bob can condition.
Great.
We've got a bunch of specialists.
Now we want to implement our suggest consultant method.
Will set array list string and the names variable
to be the result of treatment specialists
dot get with treatment passed as the parameter.
That gets us the list of names for that specific treatment.
This is the same thing we did in our add treatment specialist method.
But now, instead of adding to the list, we just print out the names
and say these are the people you might want to work with.
So we'll just make a little loop, and then we'll print out each of the names
with a little question mark.
Great, now let's run it and see if it works.
Oh, no.
We have an error.
It's a null pointer exception.
OK, where's that coming from?
Let's click and see.
Oh, interesting.
We're getting a null pointer exception when we're
trying to access the list of names.
Let's put a break point here and see why.
Here we are at the line where we get the names.
And if we step over, we see that the names array is equal to null.
So why is names equal to null?
Well, we can look at our treatment specialist map.
And we see that we have our key, which is color,
and we have our value, which is Sylvie and Sandrine.
They're right there.
So why isn't it working?
OK, let's stop execution and investigate.
What's actually happening is that Java is looking through the treatment
specialists map, comparing each of the keys to the treatment
that we're passing in.
And if it finds a match, then it will give us a list of names.
But it's not finding it.
That's why the list is coming back null.
Let's make a couple of dummy treatment variables to look at this directly.
So say we make a new treatment t1, called fake treatment,
that takes no time.
And then I make another one, t-2, that has the same name
and also takes no time.
And then, if we print out t-1 equals equals t-2 and t1 dot equals t-2,
we know for sure that the first one will be false because that's
comparing object references.
And t-1 is quite clearly a different object from t-2.
But the treatment dot equals call is also returning false,
this t1 dot equals t-2.
That is bad news because hash maps get method also
uses treatment dot equals to find treatment equivalency.
So if our call to treatment dot equals is coming back false,
then gets call to treatment dot equals is also
coming back false, which explains why get isn't finding it in the map.
But why is treatment dot equals returning false?
Well, if we look at the treatment out equals methods implementation,
it's actually just using the dot equals it inherits from object.
And the dot equals that lives inside of object just calls the equals operation.
So it's just doing the very most basic comparison of whether the two
objects are the same object.
Now, we could fix this by brute force, effectively reimplementing the method,
by comparing each treatment and the treatment map by name,
and then finding the one we're looking for.
And this is like what I've copied in right here.
But that's awful, ugly, and totally unnecessary
since the get method already exists inside of the hash map implementation.
So instead, we just want to do this really simple thing, which is override
our dot equals method for treatment.
And that will let us compare the two treatments in a more intelligent way.
So we can go into our treatment class, since that's
the thing we're trying to compare.
We're trying to say treatment dot equals.
And we'll generate equals and hash code.
Now, these two methods always have to be generated together
because they're complicated to write, and they have
to remain in lockstep with one another.
If two objects had two same hash code, they also have to satisfy equals.
So usually the safest thing to do is just
let IntelliJ generate both of these.
Now we have to decide if we want to compare on both hours and name, or just
name.
I think for now we'll compare on just name.
And if we click through the rest of this,
these methods will appear, and now intelligently compare the name
to the name of treatments.
And now, if we go back into a hair salon and run our code,
having changed nothing out here, actually, it should work.
And it does.
We can see that we're getting suggestions
for who we can work with based on the treatment we want.
So this is a real point to remember.
If you're looking for something in a list, or in a map, or some collection,
and you know that it's there, and you know that you're looking correctly,
you probably forgot to override hash code and equals.