
ELISA BANIASSAD: It's perfectly reasonable
that a method would throw different exceptions in different situations.
So for instance, our animal might not eat because it's not hungry,
or it might not eat because it's allergic to the food
that it's been given.
So in that case, it could throw a different exception
in a different situation.
So here we would declare another exception
being thrown that might be called the allergy exception.
And again, if this exception is thrown then it has its own kind of pathway
down.
The keeper then, in feed, can catch or not catch this exception.
And it's completely separate from the reasoning about catching or not
catching this exception.
So it could separately throw this exception,
or declare that it's thrown inside the method signature.
And here the manager can separately catch this exception
by setting up its own catch clause that specifically relates
to this particular exception path.
Let's add a second exception to the eat method
to indicate that the animal is actually allergic to what it has eaten.
So we'll clean this code up a little bit.
And now we're going to make a new exception called allergy exception.
And now we're going to go back into animal.
And if it's allergic, then we throw this new allergy exception, great.
Once again, we added to the signature, and the keeper throws it up
to the manager, and then in manager dot manage we add a second catch
clause, this time for allergy exception.
And this time the manager will say, get the doctor,
and we'll add a bit more information to the print statement
so we can see exactly what's going on.
Now if we set these booleans up so the animal is hungry but also allergic,
we could see that this allergy exception comes through.
So the command goes down the line to feed the animals,
and then we see, caught allergy, get the doctor.
And then we see the rest of the code.
We caught the exception so we were able to keep the code running.
After programming for a while, you might have quite the collection
of these exceptions hanging around, and it
might be the case that a lot of these responses are really similar.
So then you would have duplicated catch blocks.
So imagine instead of having different responses for these two exceptions,
the manager just always says get the doctor and throws a broke exception.
So the keeper is still going to throw both of these exceptions
but the manager is handling them identically.
Once again the answer to application is introducing some abstraction.
So to eliminate this duplication, we can make a superclass
for these two exceptions.
We can make a new exception called something like didn't eat,
and now we can reroute not hungry and allergy,
so that instead of extending exception, they extend the didn't eat exception.
Now, instead of handling these individually,
we can just catch a didn't eat exception.
We could erase the second case completely.
And we can run it and see that our merge behavior will handle both
of these different exception cases.
First, let's add some print statements and make it really clear
which exception is being thrown.
Here we're seeing the animal is allergic and the manager says get the doctor.
And if we change is hungry to false, and we can leave
is allergic to be true because it'll hit the not hungry exception first, so
now if we run it we see that the animal is not hungry, get the doctor.
