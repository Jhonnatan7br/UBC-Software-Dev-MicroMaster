
REID HOLMES: One of the primary challenges
we face when we're designing our systems is designing them
in a way that makes them amenable to future change,
without making them overly abstract.
What the open/closed principle says is that systems
should be open to extension, but closed to modification.
This means that new features can be easily added to a system
without changing an existing implementation.
Now most design patterns explicitly support the open/closed principle
by providing simple extension mechanisms that
allow us to add new features while maintain
the obliviousness of the existing code base.
We've actually already seen the open/closed principle in practice
for Mario, so here we figure with Mario and enemy.
And if we wanted to add a new figure to this game,
for instance to make it multiplayer, all we need to do is extend figure.
Right so say our new requirement is to make Mario multiplayer,
so we want to add Luigi.
All we need to do is add a Luigi class here.

And have that class extend the existing figure implementation.
The same thing might happen if we were told to make Mario 2049.
All right, so we want to go and have a replicant turtle.
So all we need to do is, again add a new class here
and have it extend this figure.

And again, we just have it extend our existing figure implementation.
So if we think about how the level class worked before,
it just has references to figure.
So it's completely oblivious to what these subtypes are.
So we're able to make these extensions without changing the existing
game at all.
The old input class is too tightly bound to this notion of key input,
so what we needed to do is build a better abstraction.
So now we have this notion of an abstract input.
But we don't want to lose the functionality that
was here in input before.
So what we want to do is actually move that into a new class called key input.

And key it simply extends the abstract input class that already exists.
And now we have the same functionality that we had before.
But going forward if, we wanted to add more features to this system in terms
of the types of input that are supported,
we can do them in ways that don't require
any type of additional refactoring.
For instance, if we wanted to add touch input,
all we really need to do is add a touch input class.

And again the touch input class just extends the abstracting implementation
that we already have.
And in this way level is completely oblivious to these new forms of input
that we are adding to the system.
So this is an example of how open/closed can make it
so our systems can be easily extended without modifying a existing
implementation.
Sometimes this will require small refractors to make possible.
Sometimes it can be hard to know when we want
to enable extensibility of our classes.
Because if we make our whole systems extensible all the time,
the system would become overly abstract and hard to reason about.
There are also other specific reasons why we might
want to inhibit extensibility as well.
For instance, there might be specific performance implications
of an extension that we want to inhibit, or there
might be security access problems that we want
to avoid by inhibiting accessibility.
Ultimately, supporting the open/closed principle is fairly straightforward.
All you need to do is design effective high level abstractions
that future developers can use to extend our existing systems.
By the same token, it is also easy to violate the open/closed principle.
For example, if you are building a high level superclass
that you know is going to be extended in the future,
and you start to check for the types of objects
that you're going to encounter runtime, for example using instance objects,
you can make it so your implementation can't actually be easily extended.
Or at least can't be extended in an oblivious way to that supertype.
And what I mean by that is if you're using instance objects to behave
one way if you encounter type A, another way if you encounter type B,
when you had type C or type D, a superclass
might not actually know what to do, and you
want to avoid that type of situation.
Similarly, we will also see that super types will
set their fields to be private, and this makes it
so that subtypes are oblivious to the data structures that
are used in the supertype itself.
And in that way we can also ensure that the subtypes are better insulated
from changes in the supertype.