
REID HOLMES: It's often the case that we want
to execute some code that isn't running on our local machine.
For instance, if you're calling a cloud-based service,
or you're executing some program on another machine on your local area
network.
This is known as Remote Procedure Call, or RPC,
and has been around since the 1970s.
RPC has all kinds of problems.
You need to figure out how to name the thing you're going to call.
You need to figure out how to format the parameters that you
want to pass to that thing.
And you need to figure out how to format the return
values that are going to come back from that remote procedure call.
Also, since this is executing on the network,
you also need to figure out how all of the network protocols
work for transferring all of this data to your remote host
and getting the results back.
Ultimately, this is a really simple idea.
We just want to call some remote code and get a response back.
But in reality, all of these other details really just get in the way.
So at a high level, what we want to do is
we want to have our local machine make a request to some remote service.
And when that remote service is done doing the computation or the task
that we requested, it will go and send the response
back to the local service that can then go and act on the response
appropriately.
One context where you will have seen this many times in the past is the web.
So your local client in the web-based context is your web browser.
And you specify the resources you want to access using a URL.
So you give your web browser a URL, and that makes a request
to a remote server, to a web server.
And that server will generate the content that you asked for
and send it back to you in the form of HTML that would then be rendered
by your browser for you to consume.
REST stands for Representational State Transfer,
and is a software architecture for distributed hypermedia applications.
REST was invented by Roy Fielding in the 1990s
as he was a PhD student at UC Irvine in California.
The way REST was developed really captures
how Roy thought about distributed hypermedia applications at the time.
To him, the web was a large collection of independent remote services
that a user accessed by moving along hypermedia links
from one service to the next.
In this way, the independent services didn't
need to maintain any kind of state about the clients they were interacting with,
and just simply forwarded users along those links
to new, other remote services.
The core design decisions behind REST were
chosen to address many of the fundamental challenges facing
web-based software systems.
What Roy wanted to do with REST is to provide a uniform interface
for accessing layered independent systems that was simple, reliable,
scalable, and extensible.
And if we think about the web we use today, all of these properties
still hold true for the systems that we're currently designing.
REST-based systems are subject to several high level
architectural constraints.
The first is when clients want to reference a remote REST service,
they need to use a naming scheme that all REST services can understand.
And in the REST world, we use something called Uniform Resource Identifiers
to really specify what the names we want to access on the remote service are.
URLs, which you're used to using within your web browser,
are a subset of all possible URIs.
One nice thing about using URIs is they provide
a really simple and transparent mechanism
for naming remote REST services.
REST-based services all use standard access methods
for parameterizing the requests being made from the client
to the REST service.
The access methods that are most commonly used
are get, put, post, and delete.
When a client makes a request to some remote URI using the get access method,
the service is probably going to return a description
of the thing you're requesting.
But if they make a request to the same URI but with the delete access method,
the service will go and delete that resource.
So the nature of the access method that you specify along with your request
is extremely meaningful.
The next architectural constraint is that REST-based services communicate
using intermediate representations.
So when a client makes a request to a REST service,
and that REST service wants to return a response, what it will do
is it will generate a representation of its internal data
that's amenable for client use.
So that response will be formatted, maybe in terms of XML or HTML or JSON,
as makes sense given the request it was given.
And that will be transferred back to the client.
In essence, what the REST service is doing is
it's enforcing information hiding from the client.
So the client doesn't actually see the back end representation
that the rest of us might be maintaining.
It only sees the format of the documents that
are being sent back to the client in this intermediate representation.
The final architectural constraint is that REST services
are based on self-descriptive hypermedia documents.
What this means is when you get response from a service,
it doesn't just send a small amount of data.
It also sends other forwarding links that
help you to understand other actions you can do with this response data type
that you got back.
By using these self-descriptive hypermedia
documents, what we're really enabling is for the REST services themselves
to be stateless, which greatly increases their scalability.