
REID HOLMES: Software engineers often talk about abstraction
in terms of information hiding.
Information hiding was first proposed by David Parness in 1972
and is something we totally take for granted in the way
we build modern systems today.
So what information hiding allows us to do
is hide specific details about implementation
away from the high level interfaces of what's being provided by the code.
So it allows us, in a sense, to separate that
which varies from that which stays the same if we
wanted to think about it concretely.
So that when varies is the implementation.
How we implement our code is going to vary
over time as we make minor tweaks and refinements and improvements.
But that which stays the same are the high-low method names
that a user is going to want to be performing.
So you could think about it in terms of actions.
The actions that a character within Mario is going to perform
are going to stay the same.
But the implementations that underlie those actions are very likely to vary.
The same with the data models that capture those actions.
So where we hide fields and we hide the implementation
is all within the umbrella of information hiding.
Let's take a look at what information hiding means for the gravity interface
we saw previously.
All right.
So here we have a public class falling which implements gravity.
Remember gravity encapsulates this notion
of setting gravity and calculating displacement.
And here in terms of information hiding what we've added
is this notion of this private field gravity.
So gravity is private and it can only be accessed
by instances of the falling class.
There isn't even a getter so no way to get this information externally
or extracted from the falling class.
One other thing to keep in mind is that we have this method
here-- calculate displacement.
And it's going to go give us-- given our current rate-- what
is our displacement for while this character is falling
for this gravitational constant.
And one thing that information hiding does
is it goes and hides the implementation of this method.
We have no idea what that implementation is.
And this is really powerful.
Because as a developer who's using this method, all we need to know
is that we call the method and we get a displacement.
We don't need to know its implementation.
So it could be that the Mario game developers in the future
or if you or the Mario game developer, you
could go and change this implementation while preserving this name.
And you'd be able to support much more complex or rich physics models, which
might be great for future versions of the game.
So that gives you the flexibility to change your implementation
without any users of this method being influenced.