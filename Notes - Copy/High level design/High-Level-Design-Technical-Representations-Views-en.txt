REID HOLMES: When we're diagramming our systems, what we really want to do
is we want enable stakeholders to get different views of how
the system will end up being built. And one common way for doing this
is using UML diagrams.
So UML diagrams really break down into two broad categories.
The first are structural diagrams, and the second are behavioral diagrams.

And within these two domains, within these two types of diagrams,
there are different sub diagrams.
Some of which you've seen before.
So the first are class diagrams, and within behavioral diagrams,
you see sequence diagrams.

There are also other types of diagrams within both of these categories.
So within structural diagrams, we also have deployment diagrams,
and within behavioral backgrounds, we have state machine diagrams.

And each of these different diagrams provide
different views on the execution-- well, the structural behavior--
the structural composition of the system and the dynamic execution
of the system.
So each of these different types of diagrams
can be considered views into our system.
And each of these views have different strengths
and are useful for different stakeholders.
And the reason why they're useful for different stakeholders
is each emphasizes different specific attributes of the system.
So from a developer's point of view, a class diagram
is great because it can show you what elements you want to build.
But for instance, as a DevOps engineer, you
might be really interested in where those different classes are
going to execute at runtime.
Now one thing to keep in mind is as we build these different views,
we want to make sure that they remain internally consistent.
Because if a developer just looks at one diagram
and goes and builds according to that diagram
but that diagram is inconsistent with a different diagram,
we'll end up having problems when we go to deploy and roll out our systems.
At the same time, though, when we're checking for inconsistencies
between our diagrams, sometimes those help
to show key problems with our designs itself, right.
So if we have a sequence diagram and we realize
that we really need to get information from one class to another
and we have no way to do that, often it causes
us to go back and change our class diagram directly or change our design.
So we can really learn things also by trying
to maintain the consistency between these different diagrams.