
REID HOLMES: Statelessness is a core architectural constraint
for all REST based systems.
What this means is that REST clients are responsible for maintaining
all of their own state as they proceed through their transaction.
For example, a REST client wouldn't ask the server for the next result.
They would say instead, give me the ninth result for this particular query.
And in that way, their request encapsulates both which
result they want and what the query is.
It doesn't rely on the server having to know what those parameters are.
This is important, because it makes REST based servers much easier to scale,
and enables caching and server switching in a way that wouldn't otherwise
be possible.
Now, this might seem confusing because obviously
REST based services need to maintain all kinds of state.
Every resource is itself state dependent data.
And it turns out there are two types of state.
There's reserve state and there's application state.
And while reserve state is totally fine to maintain on the server,
clients need to maintain application state themselves.
So when you're designing REST based systems,
it's important to distinguish between reserve state and application state.
The main way that REST based systems enable
statelessness is through a property called connectedness,
which leverages the self descriptive nature of REST based representations
to enable those representations to describe
the actions that can make sense for that representation going forward.
For example, if you use the GitHub REST API to create a new project,
the response could simply be 200 and an empty body.
But a better representation that leverages connectedness
would return a body that would have all of the details about what
you could do with that repository now that it's created.
For instance, there would be links to the issues
for the repository, the stars for the repository,
the watchers for the repository, and in that way, all of these extra details
would help connect that object to the rest of the representations
within the back end.
At the same time, this representation would still
manage to hide other implementation details.
So it's important that you don't return data that leaks information
about your implementation, but instead just connects
a resource to the other resources within your system.
Although API are forever, every successful system really
needs to evolve their APIs over time.
In REST based systems, we do this through a process known as versioning.
One key reason why we want to version our APIs
is so that we don't break existing clients.
Fortunately in the REST space, we have many different ways
to version our APIs, but we'll talk about three of them concretely now.
The simplest way to version an API is to just build it into the URI explicitly.
So here we have v2/users.
That's version two of our users API.
If we created version three, we'd have v3/users.
And as long as we still responded appropriately
to the v2/users end point, the clients would not
be affected by adding the new version.
Another way is to build it into the query.
So here we're saying users/?v=2.
So we append the version as a query parameter.
And that's another way really similar to doing it with a path.
Finally, we can actually augment the header itself.
So here we're saying API version colon 2.
We're adding the version number explicitly into the header.
The nice thing about this approach is we don't have to change any client
code at all if we add a new version.
Another common task for REST based services is authentication.
Authentication is important for these services,
because they are typically running remote,
and you want to make sure that the user who's making the API requests
are actually authorized to do so.
Authentication is also a really nice way to keep track of per user access limits
as well.
For instance, if an API user can make 1,000 requests an hour,
you can enforce this by forcing them to authenticate their API
usage with your service.
One easy way to perform authentication is using HTTP basic authentication
over HTTPS.
This basic authentication approach is supported by many different platforms.
Alternatively, you can use cookies to track your authenticated users.
Finally, the most common approach is to use a token based authentication
system such as OAuth or OAuth 2.
REST based services provide the opportunity
to collect all kinds of useful analytics about how your APIs are being used.
For instance, by instrumenting your APIs,
you can find out what the average response time for your APIs are,
what your most popular APIs are, which of your APIs
have the highest error rates.
You can also instrument your specific users if they have been authenticated.
Which users use the most requests?
Which users use the fewest?
Should you have pricing tiers that differentiate one set of users
from another based on their usage?
All of these questions, you can answer by providing analytics
on top of your APIs.
The design concerns we talked about previously in terms of general purpose
APIs also apply to REST APIs.
Your REST APIs should be small.
They should do one thing well, and they shouldn't leak
their internal implementation details.
Also, you should consider their usability
so that clients can use them effectively.
Just because the REST API seems simple, it
is important not to underestimate the difficulty associated
with building a complex, long lived REST based system.
When you're designing your systems, it's important to both think
about both their flexibility and their documentation.
By designing a flexible API, you make it so your API
can be used by many different clients in many different ways.
This increases the flexibility for the clients,
and also makes it easier for you to make back end changes
without impacting those clients unduly.
In terms of documentation, since REST APIs seem relatively limited,
since you're just using an access method and a URI,
you need to provide really good documentation.
The documentation should often include examples
that show how the API should be used and what sample return documents look like.
This will make it a lot easier for your clients to use your API effectively.