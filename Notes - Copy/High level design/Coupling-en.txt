
REID HOLMES: As I just mentioned, coupling
captures how strongly connected program elements are to one another.
At the same time, not all kinds of coupling
are equivalently problematic for software evolution.
In this screencast, we will look at some concrete examples of coupling
to help you reason about the coupling within your designs.
Since these are small concrete examples, we'll
be talking about coupling between classes and methods,
rather than components or modules.
The way that we're going to reason about coupling is in terms of a flowchart.
The first attribute we will consider is whether the coupling
arises because of data stored and manipulated between different classes.
Data coupling happens when classes share data
through simple primitive parameters.
In this example from the level class, we can see that the callers of setSize
are only sharing primitive width and height parameters.
Since primitives are built into the language,
the data types themselves do not impose more coupling on the system
than the method call itself.
Too many primitive parameters, though, can indicate poor data
partitioning within the system.
So just using parameters alone is not a panacea to avoid problematic coupling.
Stamp coupling occurs when classes are coupled through data structures
in well-defined public types.
The example above is from Mario.
Here we can see that any invoker of setState
also needs to know about the SizeState enum.
This works well when we have small well-defined interfaces,
but is more prone to maintenance work than data coupling,
because custom-defined types encode more constraints
and are much more likely to change due to the diversity of fields
that they contain.
Control coupling arises when a caller controls the flow of computation
within another unit.
This is problematic, because it means the caller needs to know something
about the implementation of the callee that they probably shouldn't.
In our example here from the keys class, what the status parameter does
is not clear and could be improved by just having two handler methods that
clarified what they are doing if the flag was true or false with much more
descriptive names.
And if you think about the implementation of the handler method
itself, you can see the problem.
Because within handler, there probably is
an if block that checks the value of the status parameter
and executes one piece of functionality if the status is true,
and another piece if the status is false.
And in this way, callers of the handler method
need to know something about the implementation of that method
that they really should be oblivious of.
Now, there is one more kind of data-oriented coupling
that we skipped by earlier, and that's global coupling.
And global variables are the root cause of this kind of coupling.
Global variables make it much harder to reason
about the flow of data throughout a program
and makes it easier to have subtle ordering bugs show up as the system
evolves, because the global state might be
changed in ways that were not expected.
In this example from Gage, dollar sign is itself a global variable.
Here, you could imagine computing this.view at the start of the program
lifetime, but at some later time in the execution changing that view,
but still having a stale this.view reference within Gage that
would probably cause some kind of problematic fault.
The use of global variables also significantly impacts
the reusability of code and decreases the testability of code.
Finally, we have content coupling, which is
the most problematic form of coupling.
This occurs when the internal state of one unit is modified by another unit.
The Mario system that we've been using doesn't
have any examples of content coupling, but this is what one would look like.
Here you could imagine that the Mario hit
code could change the dead flag in opponent
directly, instead of using a method.
But you could see how this could be a problem if the enemy itself was a boss,
or there's other reasons why that flag couldn't just be set to true.
We want those types to be able to control their own internal state,
so this type of content coupling can introduce
all kinds of unexpected failures.
Content coupling really results when there's
a breakdown of information hiding in an encapsulation
and represents the most fundamental violation of well-intentioned designs.
It's important to remember that coupling is a natural part of software.
To accomplish complex tasks, you will naturally
have some complexity between the parts of your system.
This is why coupling can be thought of along this kind of continuum.
While you should absolutely avoid content and global coupling,
being aware of the benefits and drawbacks
of the other kinds of coupling will help lead you towards better designs.
Ultimately, reasoning about how your code is coupled
is important for increasing the long-term quality
of your system, especially in terms of evolvability, reusability,
and testability.