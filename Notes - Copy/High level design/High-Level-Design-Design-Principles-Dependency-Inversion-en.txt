
REID HOLMES: Dependency inversion is the final solid design principle.
And what the dependency inversion principle says
is that classes should depend on abstractions, not on implementations.
At its core, what this does is it decouples implementations from one
another by introducing abstractions, usually
in the form of interfaces between them.
So what we'll do is we'll go and introduce new interfaces
and have lower-level classes implement those interfaces.
But the clients only have to depend on the interface itself,
making the code easy to reuse in the future.
Let's take a look at dependency inversion
in terms of our NPC-type hierarchy that we've talked about before.
We've made a slight change here.
We've added this common NPC abstract class
to the middle that provides some base implementations for SetAI and Update.
But Enemy and Turtle just extend that, and they together
implement the NPC interface.
And one thing you'll notice here is that there
is a concrete link between common NPC and this implementation, AI.
And an AI class isn't just going to be a tiny, little box like this.
It's likely to be a large, complicated class.
It may have a whole suite of dependencies on its own,
maybe in other libraries, other data sources, who knows?
There could be a lot actually in this box.
And what we want to do is we want to make
it so common NPC's easier to reuse without having to also reuse
AI and all of its other dependencies.
So the way we can tackle this is to make it
so that instead of depending on AI directly,
common NPC depends on some type of abstraction that AI can implement.
So what might that look like?
Instead of having common NPC depend directly
upon the AI class, what we've done here is we've gone and introduced
an agent interface.
And now this common NPC class only depends on the interface itself.
And the interfaces are relatively small.
They only contain a few lines of code each
that declare the public methods that are available within their subtypes.
So if you wanted to reuse common NPC now, all you would need to do
is reuse this small interface, and you could
include any other type of concrete implementation of this interface
that you would like.
This also makes it really easy to provide different AI implementations
within this system, because all we need to do now
is to go and extend this agent interface,
and we can use any other type of AI.
So this makes it really easy to, again, make our system open for extension.
So let's take a look at one of those now.
So here what we've done is we've gone and extended the agent interface
with a deep learning AI.
It's a different type of AI than we might
be interested in trying out in our game, right?
So not only have we made it easier to reuse common NPC without reusing
any specific, concrete subtype, we've also
made it more amenable to future change by enabling this type of extension.