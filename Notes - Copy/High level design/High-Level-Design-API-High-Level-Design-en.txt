
REID HOLMES: Now, we've just finished saying that APIs are extremely flexible
and they're the way that we enable all programmatic interaction.
So it's going to be tempting to think that we
should make APIs for everything.
Let's just make everything accessible by publicly-available APIs.
And in one sense, that makes sense, because when we're designing APIs,
we want to maximize their utility, because we want our APIs to be used.
For some companies, their APIs are their sole product, right?
If you're building an API platform.
So this can be really important.
But at the same time, there are some major drawbacks of having these APIs,
and that's technical debt.
So when we're designing our APIs, we want
to maximize utility while trying to minimize
our technical debt as much as possible.

And this can be a difficult process in general.
So as with the traditional design process, when we're designing APIs,
we need to get a bunch of stakeholders together.
We need to figure out what the use cases are for APIs.
And we need to figure out what their costs are going forward,
because we're going to need to support these
for a long, long time in the future.
And this really is an iterative process.
So going through an iterative design process, just as for a whole system,
is really important in this space.
There are a variety of high-level API design
principles that are used in practice, but we'll go through four of them
right now.
These were really popularized by Josh Bloch at Google.
He was actually the Chief Architect for the Collections Framework within Java
as well, so he has a lot of great experience in designing APIs
that have been widely used in practice.
So let's take a look at a concrete example.
Assume you have a method called the getPaidUserAndSortByName().

So one of the first API guidelines that are used in practice
is that APIs should do one thing, and do it well.

And if you take a look at this method here,
it's actually doing a lot of things.
It's getting paid users and it's sorting.
But what we can do is we can try to simplify this API to be easier
to use and interact with.
So let's change it, here.
All right, so what we've done here is we've simplified the API from being
getPaidUserAndSortByName() to getUsers that takes a Boolean for whether or not
the user is paid, and sortIndex, which is an index into the fields within
the user object for sorting.
OK, so this really simplifies the name of the API itself.
But the next high-level guideline is that APIs should never
expose internal implementation details.

And there really is a red flag here in this example,
and this is sortIndex, in terms of internal implementation details.
sortIndex is an index into the inside of the user object
that's being tracked by this API.
And we really shouldn't be exposing that to the users.
So let's re-factor this in a different way
again, to try to adhere to this design guideline.
All right, so what we've done here, instead,
is we've changed from sortIndex down to this key notion, right?
So we're using a key instead of an index.
And this Users.KEY will end up being an enumeration that's
a part of the public API as well.
So as an API consumer, you can go and read the documentation
and understand what those correct keys are.
So that helps to make this part of the API actually visible to the clients.
But one other design piece of advice that's often given--
and this might be the most important-- is that APIs
should be as small as possible.

And what this suggests for this API is maybe
we don't need this notion of sorting it all.
Maybe the API shouldn't be doing that for us,
and the clients should instead take care of sorting
in whatever way they see fit.
So that could re-factor this method to look more like this.
All right, so this makes it much simpler, right?
So now as the API producer, you don't need to worry about all
of the different sortings that could have
been provided through this Users.KEY mechanism, right?
And you leave that to the client-- to the API consumer--
to figure out how to sort on their own.
And one final high-level piece of design advice for designing APIs
is to consider API usability.

And this feels a little bit odd, right?
Because when we talk about APIs, we say that they're for programs
to communicate with one another.
But an engineer-- a software engineer-- would
have had to read the documentation for that API in the first place
to figure out how it worked and make the code do what he wants, right?
And in this case, if we wanted to make this API just a little bit easier
to use, we would just add information about the return type as well.
And in this way, the developer can read this simple signature
and have a really clear understanding of what the parameter is
and the return type that they're going to get back.
So thinking of the usability of an API is a critical piece
when we're trying to make our APIs so that people
can use them as effectively as possible, and with as few errors as possible.