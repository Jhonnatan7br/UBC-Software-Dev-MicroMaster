
REID HOLMES: Encapsulation is one of the most common mechanisms
for enabling abstraction with modern programming languages.
The way languages do this is, typically, through the use of interfaces.
What interfaces allow us to do is it allows
us to encapsulate that data and behavior of a class
or interface and separate it from its implementation.
And that's what encapsulation is really all about.
So let's take a look at this in a concrete example from Mario.
Imagine we want to capture or encapsulate the notion of gravity
so that our physical models don't need to consider that when
they're evaluating how quickly Mario falls through a level.
And this could be useful if, for instance, we
wanted Mario to go through some levels on Earth and other ones on the moon,
or on other planets.
So one thing that a level would need to do
is it would need to build, to inform the gravity instance that
would change from level to level.
So we need to be able to change the gravitational constant.
So we'd have a method for that.

So this method would allow a level to go and set the gravitational constant
for that specific level.
But for Mario, as he falls through the level and is calculating his movement--
because Mario has that move method--
he would also would want to be able to figure out
what kind of vertical displacement should he
expect given his current acceleration.
Now, he doesn't know what the gravitational constant of that level
is, but he still needs to be able to handle his movement.
So we need to give Mario a method that he
can call to figure out how far his vertical displacement would
have changed as he's falling.

And in this way, when Mario is going to calculate his displacement,
he's just going to call this method.
So what the gravity interface allowed us to do
is it allows us to encapsulate this notion of gravity
all within one part of the system.
So the level can go and call set gravity,
to set the gravitational constant for that level.
But Mario can also interact with calculate displacement directly
to figure out how much he's moved vertically through a level as he falls.
But when Mario is making this call, he doesn't
need to know anything about the gravitational constant.
This has all been abstracted away.
It also simplifies the Mario implementation,
because Mario and the level don't need to communicate directly
about the gravitational constant for that method.
So this has really gone and encapsulated this whole concept within this one
interface in the application.