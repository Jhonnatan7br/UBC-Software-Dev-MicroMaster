
REID HOLMES: Language constructs are continually
evolving to enable developers to better focus on their task intent,
instead of worrying about the underlying execution context of their code.
While methods and functions are the simplest language constructs
that we use to improve the structure of our programs,
other more advanced features have also been developed.
Promises are one such example.
Promises allow sequences of asynchronous operations
to be developed without resorting to nested callbacks
and are written in a way that mimics synchronous method calls.
First, let's take a look at a concrete example
of about how we might add remote server functionality to Mario using callbacks.
We'll start by declaring a function that enables
us to connect to a remote server.
This function will take two parameters-- the room name itself and the username,
so that we can create the room and add a user with a specific name into it.
We'll start by calling a private function that
takes a room name and a parameter that is
a callback using the err first idiom that is common in callback style
programming.
So when createServiceCB returns, it will return an error in this err parameter
if something goes wrong.
So the first thing we need to do is write up
a check that sees if there is an error and handle it appropriately.
And if there isn't, we can then go and assume
that the server parameter has been populated,
and we could do something with that.
So we'll go and call server.join, which takes a username,
and again, another callback using the err first idiom.
As we did previously, we also need to handle the error parameter if something
went wrong when we called server.join.
Otherwise, we can assume success and add the success code that we need.
This example just has two layers of nested callbacks,
but it's easy to imagine what this would look
like if we needed to call another asynchronous function
inside server.join as well, and another one inside that afterwards.
So the more and more asynchronous functions we add,
the harder it is to actually keep track of what's going on within our program.
Remember also, that asynchronous functions can't throw exceptions
in the normal way, so shortcircuiting a deep nested chain
can be really problematic.
Now, we'll take a look at what this looks like in a promisified version.
Some instead of callbacks, let's use promises.
And we can see how this language construct
can make our code easier to understand.
We start by calling a private function called createServer, which takes a room
name and returns a promise.
When that promise returns successfully, it will call this then function
with the provided server parameter.
But we also want to handle if there is an error, if something went wrong
or if an exception is thrown, so we'll add a catch clause here.
And this will handle the cases where createServer
throws some type of exception or explicitly is rejected.
Now, of course, when we hit the then function,
we also want to go and move along with our chain.
So we'll call server.join on that parameter
and again, chain in another then clause, so that when server.join is successful,
we can go and handle that success.
What did the promisified version give us?
Well, here we call createServer.
And if it works, we move into server.join, and if it works,
we handle success.
And if an error is raised in any of these steps,
we'll call this catch clause.
And this provides a really straight-forward mechanism
to think about how this asynchronous code is going to execute.
Also if we wanted to add more and more asynchronous steps,
we would just go and add them within this then clause
so we can easily chain in more asynchronous actions without it
seeming overwhelming.
In these ways, promises represent one really important language construct
that makes it much easier to work with asynchronous code,
and makes that code easier to evolve and maintain in the future.
