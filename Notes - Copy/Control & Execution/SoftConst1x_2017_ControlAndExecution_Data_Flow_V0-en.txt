ELISA BANIASSAD: OK, so now we're going to look really specifically
at data flow.
And that's how information is passed around in a program.
And so to do that, I'm just going to give a quick reminder of what we've
just talked about, which is variables.
So let's just set up the ground rules for talking about data flow.
So say we have a variable of type int, and it's called x.
That means that we have an x, and it has a little box.
And then we have another integer called y,
and that sets up a little y with a little value slot.
And then we can assign a value like 4 to x, which puts the value into here.
So this causes this value to come in.
And then, remember, we can assign one value to another place.
So we can say y equals x.
And that doesn't mean that y will point to x.
That means, in this case, that the value from in here
is taken and copied down to here.
So in this case, it's a simple value.
It's a primitive type, so the 4 is just copied from this slot into this slot.
So this is a major change.
Again, we have to really notice this.
This is a major change from what you've seen
before, because in previous languages, like in functional languages,
generally you can't do this changing thing.
You can't then say, y equals 5 and have this go away and this become 5.
ability to change the value of a variable--
puts the varying in variable--
is specific to imperative programming.
It doesn't exist in functional programming at all.
OK, so now let's look at the flow of data
when we're talking about object references.
So here we have the code that we had before, starting from the same spot.
We have two dogs--
d and Fido.
So we have d--
with a spot that is going to reference a dog--
equals new dog that's set up-- our dog object.
And set up a reference from d to the dog object.
That's what the assignment statement did.
Then we have a second dog, Fido, that holds a reference to a Dog object.
And we've set it so that it is the same reference as the one held in d.
So what that does, mechanically, is it looks inside of d and it copies
that value down into Fido.
So the fact that this arrow points here means
that this arrow will also point here.
So this comes, now we have two references to the same Dog object.
This is kind of the set up that we had before.
And so remember, if you changed Fido's name, it would change here.
And if you could change d's name, it would change here.
And so they're changing the same object.
Now remember that in imperative languages and in Java,
we can mutate our data.
So we can change the value that's held inside of here.
So we can then say, Fido equals new Dog.
And this code will make a new Dog object.
Sorry, I gestured like this, but it doesn't copy it from here.
It copies it from the class definition.
So there's an imaginary class definition here for dog.
It copies it, and it does all the construction.
It does all the allocation.
And it makes a new Dog object--
Dog object 2.
You don't really need to worry about these names,
but they would be distinct.
And so we have this new Dog object, and this assignment statement
is now going to say that we want to have it such that Fido
is referencing this new Dog object.
So instead of having this--
I think I can erase.
Instead of having this like this, instead, it
would now reference this Dog object.
So this copy would no longer exist.
So now we have d, which represents this new dog,
and Fido, which references this new dog.
So now if you said Fido.name equals Fido, that would change down here.
And if you said d.name equals Jim, that would change up here--
Jim.