# Software Engineering Condensed Summary

## 1. Core Concepts
- **Programming Languages**: Bridge human ideas to computer execution, balancing **syntax** (structure) and **semantics** (meaning).
- **Execution Models**:
  - **Interpreted**: Executes top-down.
  - **Compiled**: Translates code to a lower level before execution, enabling optimizations.
- **Typing**:
  - **Statically Typed**: Types are declared and checked at compile time (e.g., Java).
  - **Dynamically Typed**: Types are tied to runtime values (e.g., JavaScript).
- **Concurrency vs. Asynchronous**:
  - **Concurrency**: Manages multiple simultaneous tasks, often with threads and shared memory (e.g., Java).
  - **Asynchronous**: Handles long-running tasks without blocking the main thread, using an **event loop**, callbacks, and promises (e.g., JavaScript/TypeScript).

## 2. Software Processes
- **Traditional Models**:
  - **Waterfall**: Linear, sequential phases (Requirements -> Design -> Implement -> Verify -> Maintain). Inflexible.
  - **Spiral**: Iterative, with a focus on risk analysis in each cycle.
- **Agile Methodologies**: Prioritize flexibility, customer collaboration, and rapid iterations.
  - **Extreme Programming (XP)**: Focuses on communication, simplicity, feedback, courage, and respect.
  - **Test-Driven Development (TDD)**: A core XP practice. Follows a **Red-Green-Refactor** cycle: write a failing test (Red), write minimal code to pass (Green), and then clean up the code (Refactor).
  - **Scrum**: The most common Agile framework. Work is done in **sprints** (1â€“3 weeks) by a self-organizing **Team**.
    - **Roles**: **Product Owner** (defines what), **Scrum Master** (facilitates how), **Team** (builds).
    - **Artifacts**: **Product Backlog** (all work), **Sprint Backlog** (work for one sprint).
    - **Ceremonies**: Sprint Planning, Daily Stand-ups, Sprint Retrospective.

## 3. Requirements Engineering
- **Types**:
  - **Functional**: What the system must *do*.
  - **Non-functional**: System properties like performance, usability, or security.
- **User Stories**: A common format for requirements: "As a [role], I want [goal] so that [benefit]."
- **INVEST Principles for User Stories**:
  - **I**ndependent: Can be developed in any order.
  - **N**egotiable: Not a rigid contract; open to discussion.
  - **V**aluable: Delivers clear value to the stakeholder.
  - **E**stimable: Can be sized by the development team.
  - **S**mall: Can be completed within a single iteration.
  - **T**estable: Has clear acceptance criteria.

## 4. Software Testing
- **Goal**: To find the most impactful bugs within given constraints; not to prove the absence of bugs.
- **Testing Approaches**:
  - **White Box**: Uses knowledge of the internal code structure to design tests.
  - **Black Box**: Tests based on the specification without seeing the code. Relies on **Equivalence Class Partitioning (ECP)** and **Boundary Value Analysis** to reduce input space.
- **Testing Levels (The Test Pyramid)**:
  - **Unit Tests**: Test individual functions or components in isolation. Fast and numerous.
  - **Integration Tests**: Verify that multiple components work together correctly.
  - **System Tests**: Test the entire application as a whole, often with synthetic data.
  - **Acceptance Tests**: User-driven validation to confirm the system meets business requirements.
- **Coverage**: A metric indicating how much of the code is executed by tests (e.g., line, branch, path). It helps identify untested code but does not guarantee correctness.

### 4.1. Assertions
- **Purpose**: To verify program behavior against specifications. Not just execution, but correctness.
- **Four Phase Test**: Setup (before/beforeEach), Test (with assertions), Cleanup (after/afterEach).
- **Given-When-Then (BDD)**: Emphasizes readability. "Given a state, When an action occurs, Then assert the outcome."
- **Practical Assertions**: Using `expect(actual).to.equal(expected)`, checking properties (`not.have.property`, `have.all.keys`), and handling errors (`to.throw`).
- **Numerical Assertions**: Use tolerance-based checks for floating-point numbers (e.g., `to.be.above` and `to.be.below`).
- **Asynchronous Testing**: Return promises from test cases so the framework waits for resolution.
- **Coverage Reports**: Tools generate HTML reports to show executed code, guiding where more tests are needed, but should not be the sole driver of testing.

### 4.2. Testability Properties
- **Definition**: Modifying a system to facilitate the five testing steps: **Reach** code, **Trigger** defects, **Propagate** results, **Observe** faults, **Interpret** as defect. TDD naturally promotes testability.
- **Automatability**:
  - **Importance**: Enables fast, programmatic execution essential for efficient regression testing. Low per-run cost despite initial setup.
  - **Regression Testing**: Crucial for continuous feedback on quality and quick bug fixing.
  - **Design for Automatability**: Interfaces that allow programmatic input simulation (e.g., Mario's `Keys` interface).
- **Controllability**:
  - **Definition**: The ability to set up the system in specific states required for testing.
  - **Improving Controllability**: Refactor code to avoid direct dependencies on external resources or complex object creation within constructors. Use dependency injection (e.g., passing pre-configured objects).
- **Isolateability**:
  - **Definition**: The ability to quickly pinpoint the cause of a test failure.
  - **Improving Isolateability**: Break down complex methods or components into smaller, independently testable units. This simplifies debugging by narrowing down failure sources.
- **Observability**:
  - **Definition**: The extent to which program behavior (including triggered faults) can be verified.
  - **Improving Observability**: Modify method signatures to return key computed values or states. This allows internal state to remain private while still being verifiable, improving information hiding.
- **Challenges in Testing**: Tests themselves can have defects (up to 26% of failures). Non-determinism can lead to inconsistent test results.

## 5. High-Level Software Design
- **Goal**: Manage complexity by breaking down a system into understandable and maintainable modules. This is achieved through principled **decomposition** and **abstraction**.
- **Constant Change**: Designs must evolve. It is often better to design for near and medium-term goals rather than attempting to create a "perfect" final design from the start, as requirements and system loads will change over time.

### 5.1. Core Principles
- **Decomposition**: The process of breaking a large system into smaller modules.
  - **Top-Down**: Starts from a high-level system description and progressively breaks it into smaller, more detailed components.
  - **Bottom-Up**: Starts with concrete, low-level components and composes them into larger, more abstract systems, often identifying commonalities to create reusable libraries.
- **Abstraction**: Hiding complex reality while exposing only essential parts. It allows different stakeholders to focus on the aspects relevant to them, ignoring irrelevant detail. It separates *what* a component does from *how* it does it.
- **Encapsulation & Information Hiding**: Encapsulation is the mechanism (e.g., classes) of bundling data with the methods that operate on it. Information Hiding is the design principle of concealing implementation details. A key goal is to separate parts of the system that are likely to **vary** (implementation) from those that should remain **stable** (interface).
- **Coupling**: The degree of interdependence between modules. The goal is **Low Coupling**, achieved by minimizing the number and complexity of interfaces between modules. High coupling is problematic as it makes changes difficult to isolate, hinders code reuse, and complicates understanding the system.
- **Cohesion**: The degree to which elements *within* a single module belong together. The goal is **High Cohesion**, where a module is responsible for a single, well-defined task. Low cohesion makes code harder to understand, maintain, and reuse.
  - **Levels of Cohesion (from best to worst):**
    1.  **Functional**: All elements contribute to a single, essential function (ideal).
    2.  **Sequential**: The output of one element is the input for another.
    3.  **Communicational**: Elements operate on the same data.
    4.  **Procedural**: Elements are grouped because they execute in a specific order (driven by control flow).
    5.  **Temporal**: Elements are grouped because they are processed at the same time (e.g., an `initialize()` method).
    6.  **Logical**: Elements are logically related, but their functions are different (e.g., a `StringUtils` class).
    7.  **Coincidental**: Elements have no meaningful relationship; they are grouped arbitrarily (worst).

#### 5.1.1 The SOLID Principles
- A set of five design principles for creating more understandable, flexible, and maintainable object-oriented systems.
- **S - Single Responsibility Principle (SRP)**: A class should have only one reason to change, meaning it should have only one job or responsibility. This leads to smaller, more focused classes.
- **O - Open-Closed Principle (OCP)**: Software entities (classes, modules, etc.) should be open for extension, but closed for modification. This is achieved by relying on abstractions, allowing new functionality to be added by creating new subclasses without changing existing code.
- **L - Liskov Substitution Principle (LSP)**: Subtypes must be substitutable for their base types without altering the correctness of the program. If a class `S` is a subtype of `T`, then objects of type `T` may be replaced with objects of type `S` without undesirable side effects.
- **I - Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use. It's better to have many small, client-specific interfaces than one large, general-purpose one.
- **D - Dependency Inversion Principle (DIP)**: High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces). Furthermore, abstractions should not depend on details; details should depend on abstractions. This decouples the implementation details from the high-level logic.

### 5.2. Technical Representations
- Software development involves translating an **Idea** into a **Specification**, then into a **Design**, and finally into **Code**. Moving down this path makes the representation more **concrete** by adding detail.
- **Diagrams (e.g., UML)** are the primary tool for representing designs. They must be **concrete, unambiguous, accurate, and precise**.
- **Architectural Views**: A system is often described using multiple diagrams, each providing a different **view** for a different **stakeholder** (e.g., developers, DevOps engineers). Maintaining consistency between these views is critical, and identifying inconsistencies often reveals underlying design flaws.
- **Structural Views** (Static):
  - **Class Diagrams**: Show the static structure: classes, attributes, methods, and relationships. They are the blueprint for the code.
  - **Deployment Diagrams**: Map software components to physical hardware or execution environments. They make the runtime architecture explicit, showing what runs on the client, server, etc.
- **Behavioral Views** (Dynamic):
  - **State Machine Diagrams**: Model the states an object can be in and the events that trigger transitions. They are excellent for designing event-driven systems and preventing invalid state changes (e.g., preventing a character from double-jumping in mid-air).
  - **Sequence Diagrams**: Illustrate object interactions in chronological order. They are useful for understanding the dynamic behavior of a specific feature or use case.

### 5.3. API Design
- **APIs (Application Programming Interfaces)** are formal contracts that enable programmatic interaction. Good design is crucial, as public APIs are "forever" to maintain backward compatibility.
- **Key Design Principles**:
  - **Focused & Minimal**: Do one thing well and be as small as possible.
  - **Hide Implementation**: Do not expose internal details through the API.
  - **Favor Immutability**: Return immutable objects to prevent clients from changing your internal state, and vice versa.
  - **Private by Default**: Only make public what is absolutely necessary for the client.
- **Usability is Key**: An API is a UI for developers.
  - **Visibility**: Make it easy to find what's needed and hard to misuse (e.g., use enums over free-form strings).
  - **Mental Model**: The API's structure should match the developer's mental model of the task.
  - **Mapping**: Use the type system to make the API clear and prevent errors.
  - **Feedback**: Provide immediate and descriptive error messages.
- **Process**: An iterative cycle of 1) writing a clear specification, 2) soliciting feedback, 3) prototyping (using the API in at least three different client contexts), and 4) creating thorough documentation with examples.

### 5.4. REST APIs
- **REST (Representational State Transfer)** is a dominant architectural style for building distributed, stateless web services.
- **Key Concepts**:
  - **Resources (Nouns)**: Identified by unique URIs (e.g., `/api/users/123`).
  - **Verbs (HTTP Methods)**: Define actions on resources.
    - `GET`: Retrieve a resource.
    - `POST`: Create a new resource.
    - `PUT`: Update/replace an existing resource.
    - `DELETE`: Remove a resource.
  - **Idempotency**: `GET`, `PUT`, and `DELETE` are idempotent (multiple identical requests have the same effect as one). `POST` is not idempotent (multiple requests create multiple resources).
  - **Statelessness**: Each request from a client must contain all information the server needs to process it. The server does not store any client application state between requests, which greatly enhances scalability.
  - **Representations**: Data is exchanged in self-descriptive formats like JSON or XML. These are representations of the server's internal state, not the state itself.
- **Evolution & Security**:
  - **Versioning**: APIs must evolve. Use versioning in the URI (`/api/v2/users`), as a query parameter (`?v=2`), or in a custom header to allow changes without breaking existing clients.
  - **Authentication**: Verify user identity, often via HTTP Basic Auth, cookies, or token-based systems like OAuth.

### 5.5 Symptoms of Poor Design (Code Smells)
- Indicators that a software design may have underlying problems.
- **Rigidity**: A small change requires a cascade of changes in other parts of the system.
- **Fragility**: A change breaks unexpected parts of the system.
- **Immobility**: A component is so entangled with its original context that it cannot be reused elsewhere.
- **Viscosity**: It is easier to add a hack or workaround than to follow the intended design conventions.
- **Needless Complexity**: The design contains over-engineered or unused abstractions that increase cognitive load.
- **Needless Repetition**: Duplicated code exists, indicating a missing abstraction.
- **Opacity**: The code is hard to understand; its intent is unclear due to poor structure or illogical placement of features.

## 6. Low-Level Design & Design Patterns

### 6.1 Low-Level Design Guidelines
- **Encapsulate What Varies**: Identify aspects of the application that are likely to change and separate them from those that are stable.
- **Program to an Interface, Not an Implementation**: Depend on abstractions (interfaces) rather than concrete classes. This decouples components and makes the system more flexible.
- **Favor Composition Over Inheritance**: Use object composition (containing instances of other classes) to achieve polymorphic behavior and code reuse. It is often more flexible and less brittle than class inheritance.

### 6.2 Design Patterns Overview
- **Definition**: Reusable, well-documented solutions to commonly occurring problems within a given context in software design. They provide a shared vocabulary for developers.
- **Categories**:
  - **Creational**: Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation (e.g., Singleton).
  - **Structural**: Ease the design by identifying a simple way to realize relationships between entities (e.g., Facade, Decorator).
  - **Behavioral**: Identify common communication patterns between objects and realize these patterns (e.g., Strategy, State).

### 6.3 Creational Patterns
- **Singleton**: Ensures a class has only one instance and provides a global point of access to it. It's useful for managing shared resources like a sound manager or database connection, but should be used with caution as it can introduce global state, making code harder to test and reason about.

### 6.4 Structural Patterns
- **Facade**: Provides a unified, high-level interface to a complex subsystem of classes. It simplifies the client's interaction with the subsystem by hiding its internal complexity.
- **Decorator**: Dynamically adds new behaviors or responsibilities to an individual object without altering the behavior of other objects from the same class. It "wraps" the original object, allowing for a flexible alternative to subclassing for extending functionality.

### 6.5 Behavioral Patterns
- **Strategy**: Defines a family of interchangeable algorithms and encapsulates each one. This allows the algorithm to be selected and swapped at runtime, independently from the client that uses it.
- **State**: Allows an object to alter its behavior when its internal state changes. The object appears to change its class. It is used to systematically manage a large number of states and transitions by modeling them as explicit state objects.
- **Strategy vs. State**: While structurally similar, their intent differs. **Strategy** is about *how* an object does something (the algorithm), and it's often fixed. **State** is about *what* state an object is in and *how* it transitions, which is inherently dynamic.

### 6.6 Architectural (Compound) Patterns
- **MVC (Model-View-Controller)**: A pattern that separates the representation of information from the user's interaction with it.
  - **Model**: Manages the application's data and business logic.
  - **View**: Displays the data from the model to the user.
  - **Controller**: Handles user input and translates it into actions to be performed by the model.
- **MVP (Model-View-Presenter)**: A derivative of MVC that improves testability by further decoupling the View.
  - **Model**: Same as MVC.
  - **View**: Becomes a passive interface that is updated by the Presenter. It contains no application logic.
  - **Presenter**: Acts as the middle-man, retrieving data from the Model and formatting it for the View. All presentation logic lives in the Presenter, making it easy to test without a UI. The View and Model are never directly connected.

## 7. Software Construction & Quality

### 7.1 Readability & Core Concepts
- Software construction is the implementation phase that bridges design and deployment.
- **Readability**: Code is read more often than it is written, so it must be clear. Good naming, consistent style, and logical structure make code its own best documentation. Avoid deep nesting and obscure names.

### 7.2 Code Quality & Static Analysis
- **Code Smells**: Symptoms of deeper design problems (e.g., **Bloaters** like long methods, **OO Abusers** like `switch` statements instead of polymorphism, **Change Preventers** that make evolution difficult).
- **Static Analysis**: Analyzing code without executing it. **Linters** are tools that detect bugs, enforce code style, and flag suspicious constructs (e.g., assignments in conditional statements).

### 7.3 Refactoring & Technical Debt
- **Technical Debt**: The implied cost of rework caused by choosing an easy solution now instead of a better approach that would take longer.
- **Refactoring**: The process of restructuring existing code *without* changing its external behavior. It is used to improve design, clean up code, and pay down technical debt. It is not for fixing bugs or adding features. A comprehensive test suite is essential for safe refactoring.
- **Rule of Threes**: A guideline for when to refactor: the first time you do something, just do it. The second time, duplicate it but take note. The third time, refactor.

### 7.4 Automation
- Modern software development relies on automation to make processes **reliable, repeatable, and revertible**.
- **Automated Pipeline**: A typical CI/CD (Continuous Integration/Continuous Deployment) pipeline includes automated steps for:
  1.  Fetching code and dependencies.
  2.  Building the project.
  3.  Running tests.
  4.  Deploying to a server.
- Each step provides a fast feedback loop to developers if something fails.

## 8. Designing Robust Classes

### 8.1 What is Robustness?
- The ability of a system to be resilient and recover from strange or unforeseen states, rather than crashing. The goal is to plan for failure and handle it gracefully.

### 8.2 Exception Handling
- **Purpose**: A mechanism to recover from exceptional runtime situations. When an error occurs, a method can `throw` an exception, which propagates up the call stack until it is `catch`ed by an appropriate handler. If uncaught, the program terminates.
- **`try-catch-finally`**:
  - `try`: Contains code that may throw an exception.
  - `catch`: Handles a specific exception type. Multiple `catch` blocks can be used to handle different types.
  - `finally`: Contains cleanup code that **always** executes, regardless of whether an exception was thrown or caught.
- **Checked vs. Unchecked Exceptions**:
  - **Checked**: Subclasses of `Exception`. The compiler forces you to handle them (with a `try-catch` or a `throws` declaration). Used for recoverable, anticipated errors (e.g., file not found).
  - **Unchecked**: Subclasses of `RuntimeException`. The compiler does not enforce handling. Used for programming errors that should not be caught (e.g., `NullPointerException`, `ArrayIndexOutOfBoundsException`).
- **Exception Hierarchy**: Custom exceptions can be created by extending `Exception` or its subclasses, allowing for more specific error handling and the ability to catch general categories of exceptions.

### 8.3 Assertions
- **Purpose**: A development and debugging tool to verify that the internal state of a program is correct. Assertions are used to check for things that "should never happen." They validate preconditions, postconditions, and class invariants.
- **Mechanism**: An `assert` statement checks a boolean condition. If the condition is false, it throws an `AssertionError`, halting execution.
- **Usage**: Assertions are intended for development and testing only. They can and should be disabled in production code to avoid any performance impact.

### 8.4 Testing for Exceptions
- An important part of testing is verifying that the code correctly throws exceptions under invalid or exceptional conditions.
- A common pattern in unit tests is to use a `try-catch` block:
  - When an exception **is expected**, the test calls the code in the `try` block. The corresponding `catch` block allows the test to pass. If the expected exception is *not* thrown, the test should be explicitly failed.
  - When an exception is **not expected**, any exception caught by a `catch` block should fail the test.

## 9. Extracting & Implementing OO Design

### 9.1 From Requirements to Class Diagram
- **Identifying Classes**: A common technique is to analyze textual requirements (e.g., user stories) and identify all **nouns** as candidate classes.
- **Identifying Associations**: **Verbs** in the requirements describe interactions between nouns, which translate to associations (relationships) between classes. These are represented as fields.
- **Multiplicity**: Indicates how many objects are linked (e.g., `1`, `*` for many). A `List<Type>` field implies a to-many relationship.
- **Aggregation**: A "part-of" relationship (e.g., a `Car` has-a `Wheel`), shown with a diamond, indicating that one class owns or contains another.
- **Bidirectional Association**: When two classes have fields referencing each other, shown with a line with no arrowheads.

### 9.2 Modeling Dynamic Behavior with Sequence Diagrams
- **Purpose**: To visualize how objects interact over time to accomplish a task. They are excellent for understanding and implementing the logic within a method.
- **Components**:
  - **Lifelines**: Vertical lines representing an object's existence.
  - **Method Calls**: Horizontal arrows between lifelines.
  - **Activation Bars**: Rectangles showing when a method is executing.
- They can model control flow like loops (`loop` frames) and conditionals (`alt` frames).

### 9.3 Implementing the Design
- **Fields & Collections**: Associations from the class diagram are implemented as fields. A to-many relationship is implemented using a collection like `List`, `Set`, or `Map`.
- **`equals()` and `hashCode()`**: When using custom objects as keys in a `HashMap` or storing them in a `HashSet`, you **must** override `equals()` and `hashCode()`. Otherwise, the collection will not be able to find objects correctly, as it depends on these methods for value equality, not just reference equality (`==`).
- **Bidirectional Relationships**: To avoid infinite loops when linking two objects (e.g., `student.addCourse(c)` which calls `c.addStudent(s)`), each `add` method must include a guard condition to check if the link already exists before proceeding (e.g., `if (!this.courses.contains(c))`).